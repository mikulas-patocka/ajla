{*
 * Copyright (C) 2024 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

uses compiler.parser.istring;

const unl : bytes := bytes.[ 10 ];

fn locase(b : bytes) : bytes
[
	for i := 0 to len(b) do
		if b[i] >= 'A', b[i] <= 'Z' then
			b[i] += 32;
	return b;
]

fn stretch(first last : bytes, tab : int) : bytes
[
	if len(first) >= tab then
		return first + " " + last;
	var n_tabs := (tab - len(first) + 7) div 8;
	return first + infinite(byte, '	')[ .. n_tabs] + last;
]

fn replace_if_differ(implicit w : world, implicit d : dhandle, new old : bytes) : world
[
	var h1 := ropen(old, 0);
	var h2 := ropen(new, 0);
	var l1 := read_lazy(h1);
	var l2 := read_lazy(h2);
	if l1 = l2 then [
		unlink(old);
		return;
	]
	rename(d, new, d, old);
]

fn process_consts_txt(implicit w : world, implicit d : dhandle) : world
[
	var lines := list_break_to_lines(read_lazy(ropen_lazy("scripts/consts.txt", 0)));

	var pcode_op_1 := empty(bytes);
	var ex_codes_1 := empty(bytes);
	var ex_codes_2 := empty(bytes);
	var pcode_1 := empty(bytes);
	var pcode_2 := empty(bytes);
	var pcode_3 := empty(bytes);
	var max_pcode_3 := 0;

	var current_number := 0;
	var stride := 0;
	for l in lines do [
		if len_at_least(l, 1), l[0] = ';' then
			continue;
		var comment := list_search(l, 9);
		if comment >= 0 then
			l := l[ .. comment];

		if l = "" then [
			pcode_op_1 +<= "";
			if len(ex_codes_1) > 0, ex_codes_1[len(ex_codes_1) - 1] <> "" then
				ex_codes_1 +<= "";
			if len(ex_codes_2) > 0, ex_codes_2[len(ex_codes_2) - 1] <> "" then
				ex_codes_2 +<= "";
			if len(pcode_1) > 0, pcode_1[len(pcode_1) - 1] <> "" then
				pcode_1 +<= "";
			if len(pcode_3) > 0, pcode_3[len(pcode_3) - 1] <> "" then
				pcode_3 +<= "";
			continue;
		]
		var n := ston(l);
		if not is_exception n then [
			current_number := n;
			if n < 0 then
				stride := -1;
			else
				stride := 1;
			continue;
		]
		if l = "*" then [
			current_number := 1;
			stride := 0;
			continue;
		]

		pcode_op_1 +<= stretch("#define " + l, ntos(current_number), 40);

		if (list_begins_with(l, "EC_") or list_begins_with(l, "AJLA_ERROR_") or list_begins_with(l, "SYSTEM_ERROR_")) and
		    not (l = "EC_N" or l = "AJLA_ERROR_BASE" or l = "AJLA_ERROR_N" or l = "SYSTEM_ERROR_BASE" or l = "SYSTEM_ERROR_N") then [
			if list_begins_with(l, "AJLA_ERROR_") then
				l := l[5 .. ];
			l := locase(l);
			ex_codes_1 +<= "const " + l + " : int;";
			ex_codes_2 +<= "const " + l + " : int := " + ntos(current_number) + ";";
		] else [
			pcode_1 +<= "const " + l + " := " + ntos(current_number) + ";";
		]

		if list_begins_with(l, "P_") then [
			l := l[2 .. ];
			pcode_2 +<= "	if p = P_" + l + " then return """ + l + """;";
		] else if list_begins_with(l, "T_") then [
			l := l[2 .. ];
		]
		max_pcode_3 := max(i_encode(l), max_pcode_3);
		var p3 := "	a[#" + ntos_base(i_encode(l), 16) + "] := " + ntos(current_number) + ";";
		var n_tabs := (80 - len(p3)) div 8;
		if n_tabs < 0 then
			n_tabs := 0;
		p3 += fill(byte, '	', n_tabs);
		p3 += "// " + l;
		pcode_3 +<= p3;

		if stride = 0 then
			current_number *= 2;
		else
			current_number += stride;
	]

	var pcode_op := wopen("pcode-op.h.tmp", open_flag_create, open_mode_default);
	write(pcode_op, "/*" + unl);
	write(pcode_op, " * No-copyright" + unl);
	write(pcode_op, " * A table of numbers, generated by a script, is supposedly not copyrightable." + unl);
	write(pcode_op, " */" + unl);
	write(pcode_op, "" + unl);
	write(pcode_op, "#ifndef AJLA_PCODE_OP_H" + unl);
	write(pcode_op, "#define AJLA_PCODE_OP_H" + unl);
	write(pcode_op, unl);
	write(pcode_op, list_join(pcode_op_1, unl));
	write(pcode_op, unl);
	write(pcode_op, "#endif" + unl);

	var ex_codes := wopen("newlib/ex_codes.ajla.tmp", open_flag_create, open_mode_default);
	write(ex_codes, "{*" + unl);
	write(ex_codes, " * No-copyright" + unl);
	write(ex_codes, " * A table of numbers, generated by a script, is supposedly not copyrightable." + unl);
	write(ex_codes, " *}" + unl);
	write(ex_codes, "" + unl);
	write(ex_codes, "private unit ex_codes;" + unl);
	write(ex_codes, unl);
	write(ex_codes, list_join(ex_codes_1, unl));
	write(ex_codes, unl);
	write(ex_codes, "implementation" + unl);
	write(ex_codes, unl);
	write(ex_codes, list_join(ex_codes_2, unl));

	var pcode := wopen("newlib/pcode.ajla.tmp", open_flag_create, open_mode_default);
	write(pcode, "{*" + unl);
	write(pcode, " * No-copyright" + unl);
	write(pcode, " * A table of numbers, generated by a script, is supposedly not copyrightable." + unl);
	write(pcode, " *}" + unl);
	write(pcode, "" + unl);
	write(pcode, "private unit pcode;" + unl);
	write(pcode, unl);
	write(pcode, "type pcode_t := sint32;" + unl);
	write(pcode, "type u_pcode_t := uint32;" + unl);
	write(pcode, unl);
	write(pcode, list_join(pcode_1, unl));
	write(pcode, unl);
	write(pcode, "fn pcode_name(p : int) : bytes;" + unl);
	write(pcode, "fn name_to_value~cache : list(int);" + unl);
	write(pcode, unl);
	write(pcode, "implementation" + unl);
	write(pcode, unl);
	write(pcode, "fn pcode_name(p : int) : bytes" + unl);
	write(pcode, "[" + unl);
	write(pcode, list_join(pcode_2, unl));
	write(pcode, "	return ""Unknown code "" + ntos(p);" + unl);
	write(pcode, "]" + unl);
	write(pcode, unl);
	write(pcode, "fn name_to_value~cache : list(int)" + unl);
	write(pcode, "[" + unl);
	write(pcode, "	var a := infinite_uninitialized(int);" + unl);
	write(pcode, unl);
	write(pcode, "	assume len(a) > #" + ntos_base(max_pcode_3, 16) + ";" + unl);
	write(pcode, unl);
	write(pcode, list_join(pcode_3, unl));
	write(pcode, unl);
	write(pcode, "	return a;" + unl);
	write(pcode, "]" + unl);
]

fn process_socket_txt(implicit w : world, implicit d : dhandle) : world
[
	var input := list_break_to_lines(read_lazy(ropen_lazy("scripts/socket.txt", 0)));
	var output_a := wopen("newlib/socket_consts.ajla.tmp", open_flag_create, open_mode_default);
	write(output_a, "{*" + unl);
	write(output_a, " * No-copyright" + unl);
	write(output_a, " * A table of numbers, generated by a script, is supposedly not copyrightable." + unl);
	write(output_a, " *}" + unl);
	write(output_a, "" + unl);
	var output_c := wopen("os_pos_s.inc.tmp", open_flag_create, open_mode_default);
	write(output_c, "/*" + unl);
	write(output_c, " * No-copyright" + unl);
	write(output_c, " * A table of numbers, generated by a script, is supposedly not copyrightable." + unl);
	write(output_c, " */" + unl);
	write(output_c, "" + unl);

	var groups := list_break(input, "---");

	write(output_a, "private unit socket_consts;" + unl);

	for group in groups do [
		while group[0] = "" or group[0][0] = ';' do [
			group := group[1 .. ];
		]
		var head := list_break(group[0], ',');
		group := group[1 .. ];

		var func_name := head[0];
		var rfunc_name := head[1];
		var mode := head[2][0];

		if head[2][1] = '+' then
			write(output_a, unl);

		var func :=
			"static int " + func_name + "(int idx, ajla_error_t *err)" + unl +
			"{" + unl +
			"	switch (idx) {" + unl;
		var rfunc :=
			"static int " + rfunc_name + "(int idx, ajla_error_t *err)" + unl +
			"{" + unl +
			"	switch (idx) {" + unl;

		var count := 1;
		for line in group do [
			if line = "" or line[0] = ';' then
				continue;

			var s : int;
			s := list_search(line, ' ');
			if s >= 0 then
				line := line[ .. s];
			s := list_search(line, '	');
			if s >= 0 then
				line := line[ .. s];

			if head[2][1] = '+' then
				write(output_a, "const " + locase(line) + " := " + ntos(count) + ";" + unl);
			func += "#ifdef " + line + unl;
			func += "		case " + ntos(count) + ": return " + line + ";" + unl;
			func += "#endif" + unl;

			rfunc += "#ifdef " + line + unl;
			rfunc += "		case " + line + ": return " + ntos(count) + ";" + unl;
			rfunc += "#endif" + unl;

			if mode = '1' then
				count += 1;
			else if mode = '2' then
				count *= 2;
			else
				abort;
		]

		func += "		default:" + unl +
			"			fatal_mayfail(error_ajla(EC_SYNC, AJLA_ERROR_INVALID_OPERATION), err, ""invalid value"");" + unl +
			"			return -1;" + unl +
			"	}" + unl +
			"}" + unl + unl;
		rfunc += "		default:" + unl +
			"			fatal_mayfail(error_ajla(EC_SYNC, AJLA_ERROR_SYSTEM_RETURNED_INVALID_DATA), err, ""invalid value"");" + unl +
			"			return -1;" + unl +
			"	}" + unl +
			"}" + unl + unl;

		write(output_c, func);
		if rfunc_name <> "" then
			write(output_c, rfunc);
	]

	return w;
]

fn main
[
	process_consts_txt(d);
	process_socket_txt(d);
	replace_if_differ(d, "pcode-op.h", "pcode-op.h.tmp");
	replace_if_differ(d, "newlib/ex_codes.ajla", "newlib/ex_codes.ajla.tmp");
	replace_if_differ(d, "newlib/pcode.ajla", "newlib/pcode.ajla.tmp");
	replace_if_differ(d, "newlib/socket_consts.ajla", "newlib/socket_consts.ajla.tmp");
	replace_if_differ(d, "os_pos_s.inc", "os_pos_s.inc.tmp");
]
