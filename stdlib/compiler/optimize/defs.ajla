{*
 * Copyright (C) 2024, 2025 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.optimize.defs;

uses pcode;
uses treemap;

const check : bool := false;

type node_set := int128;
type var_set := int128;
type instr_set := int128;
type param_set := int32;

record instruction [
	opcode : pcode_t;
	params : list(pcode_t);
	read_set : param_set;
	write_set : param_set;
	free_set : param_set;
	conflict_1 : param_set;
	conflict_2 : param_set;
	borrow : int;
	bb : int;
]

record basic_block [
	active : bool;
	instrs : list(int);
	pred_list : list(int);
	pred_position : list(int);
	post_list : list(int);
	dom : node_set;
	dominates : node_set;
	idom : int;
	is_idom_of : node_set;
	df : node_set;
	uninitialized : var_set;
	live_top : var_set;
	live_bottom : var_set;

	block_name : bytes;
	post_cut_nodes : int;
	pre_cut_nodes : bool;
	added_claims : list(bytes);
	guards : var_set;
	not_guards : var_set;
]

fn new_basic_block : basic_block
[
	return basic_block.[
		active : true,
		instrs : empty(int),
		pred_list : empty(int),
		pred_position : empty(int),
		post_list : empty(int),

		dom : -1,
		dominates : -1,
		idom : -1,
		is_idom_of : -1,
		df : -1,
		uninitialized : -1,
		live_top : -1,
		live_bottom : -1,

		block_name : "",
		post_cut_nodes : 0,
		pre_cut_nodes : false,
		added_claims : empty(bytes),
		guards : 0,
		not_guards : 0,
	];
]

record variable [
	type_index : int;
	runtime_type : int;
	local_type : int;
	must_be_flat : bool;
	must_be_data : bool;
	name : bytes;

	//reading_instrs : instr_set;
	writing_instrs : instr_set;
	reaching_def : int;
	defining_block : int;
	defining_instr : int;

	color : int;
	needed : bool;

	ra_priority : int;

	verifier_name : list(bytes);
]

fn new_variable : variable
[
	return variable.[
		type_index : -1,
		runtime_type : -1,
		local_type : -1,
		must_be_flat : false,
		must_be_data : false,
		name : "",
		writing_instrs : -1,
		reaching_def : -1,
		defining_block : -1,
		defining_instr : -1,
		color : -1,
		needed : false,
		ra_priority : 0,
		verifier_name : infinite(""),
	];
]

record function [
	path_idx : int;
	un : bytes;
	program : bool;
	fn_idx : list(int);
	spec_data : list(pcode_t);
]

fn function_equal(l1 l2 : function) : bool
[
	return
		l1.path_idx = l2.path_idx and
		l1.un = l2.un and
		l1.program = l2.program and
		l1.fn_idx = l2.fn_idx and
		l1.spec_data = l2.spec_data;
]

fn function_less(l1 l2 : function) : bool
[
	if l1.path_idx <> l2.path_idx then
		return l1.path_idx < l2.path_idx;
	if l1.program <> l2.program then
		return l1.program < l2.program;
	if len(l1.un) <> len(l2.un) then
		return len(l1.un) < len(l2.un);
	if l1.un <> l2.un then
		return l1.un < l2.un;

	if len(l1.fn_idx) <> len(l2.fn_idx) then
		return len(l1.fn_idx) < len(l2.fn_idx);
	if len(l1.spec_data) <> len(l2.spec_data) then
		return len(l1.spec_data) < len(l2.spec_data);
	if l1.fn_idx <> l2.fn_idx then
		return l1.fn_idx < l2.fn_idx;
	if l1.spec_data <> l2.spec_data then
		return l1.spec_data < l2.spec_data;

	return false;
]

implicit fn instance_ord_function : class_ord(function) :=
	class_ord(function).[
		equal : function_equal,
		less : function_less,
	];

record local_type_record [
	opt : bool;
	f : function;
	types : list(int);
]

record local_type_flat_record [
	non_flat_record : int;
	flat_types : list(int);
]

record local_type_flat_array [
	non_flat_array : int;
	flat_entry_type : int;
	number_of_elements : int;
]

option local_type [
	rec : local_type_record;
	arr : int;
	flat_rec : local_type_flat_record;
	flat_array : local_type_flat_array;
]

type conflict_map := list(var_set);

record context [
	local_types : list(local_type);
	instrs : list(instruction);
	blocks : list(basic_block);
	variables : list(variable);
	specialize_args : int;
	label_to_block : list(int);
	var_map : list(int);
	cm : conflict_map;
	should_retry : bool;
	num_retries : int;
	name : bytes;
	dump_z3 : bool;
	return_ins : instruction;
	op_map : array(bytes, [ -T_Bool + 1, Op_N ]);
	unint_map : array(bool, [ -T_Bool + 1, Op_N ]);
	unint_counter : int;
	llt_defined : treeset(bytes);
	get_inline : fn(function, bool) : list(pcode_t);
]
