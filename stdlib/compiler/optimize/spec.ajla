{*
 * Copyright (C) 2025 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.optimize.spec;

uses compiler.optimize.defs;

type spec_context;

fn spec_get_arg_dependencies(ctx : context, args : int) : int;

fn new_spec_context(n : int) : spec_context;
fn spec_add_variable(spec_ctx : spec_context, ctx : context, a v : int) : spec_context;
fn spec_extract_pcode(spec_ctx : spec_context) : list(pcode_t);
fn spec_pcode(pc : list(pcode_t), spec_data : list(pcode_t), un : bytes, get_inline : fn(function, bool) : list(pcode_t), verify_pattern : bytes) : list(pcode_t);
fn spec_extract(pc : list(pcode_t)) : treeset(list(pcode_t));

implementation

uses exception;
uses compiler.common.blob;
uses compiler.optimize.utils;
uses compiler.optimize.inline;
uses compiler.optimize.ssa;

record spec_variable [
	runtime_type : int;
	type_idx : int;
]

record spec_context [
	arguments : int;
	local_types : list(local_type);
	variables : list(spec_variable);
	lt_map : list(int);
	instrs : list(instruction);
	outputs : list(int);
]

const allowed_opcodes : int64 := 0
	bts P_BinaryOp
	bts P_BinaryConstOp
	bts P_UnaryOp
	bts P_Copy
	bts P_Copy_Type_Cast
	bts P_Fn
	bts P_Load_Fn
	bts P_Curry
	bts P_Call
	bts P_Call_Indirect
	bts P_Load_Const
	bts P_Structured_Write
	bts P_Record_Create
	bts P_Record_Load
	bts P_Option_Create
	bts P_Option_Load
	bts P_Option_Test
	bts P_Option_Ord
	bts P_Array_Flexible
	bts P_Array_Fixed
	bts P_Array_Create
	bts P_Array_Fill
	bts P_Array_String
	bts P_Array_Unicode
	bts P_Array_Load
	bts P_Array_Len
	bts P_Array_Len_Greater_Than
	bts P_Array_Sub
	bts P_Array_Skip
	bts P_Array_Append
	bts P_Array_Append_One
	bts P_Array_Flatten
	;

fn spec_get_arg_dependencies(ctx : context, args : int) : int
[
	var vars : var_set := 0;
	while args <> 0 do [
		var arg : int := bsr args;
		args btr= arg;
		vars bts= ctx.args[arg];
	]

	var todo := vars;
	while todo <> 0 do [
		var v : int := bsr todo;
		todo btr= v;
		var type_idx := ctx.variables[v].type_index;
		if type_idx >= 0 then [
			if not vars bt type_idx then [
				vars bts= type_idx;
				todo bts= type_idx;
			]
		]
		var ins : instruction;
		for igi := 0 to len(ctx.instrs) do [
			ins := ctx.instrs[igi];
			var ws := ins.write_set;
			while ws <> 0 do [
				var widx : int := bsf ws;
				ws btr= widx;
				if ins.params[widx] = v then
					goto found_it;
			]
		]
		continue;
found_it:
		var rs := ins.read_set;
		while rs <> 0 do [
			var ridx : int := bsf rs;
			rs btr= ridx;
			var r := ins.params[ridx];
			if not vars bt r then [
				vars bts= r;
				todo bts= r;
			]
		]
	]

	args := 0;
	for i := 0 to len(ctx.args) do [
		if vars bt ctx.args[i] then
			args bts= i;
	]
	return args;
]

fn new_spec_context(n : int) : spec_context
[
	var spec_ctx := spec_context.[
		arguments : 0,
		local_types : empty(local_type),
		variables : empty(spec_variable),
		lt_map : infinite(-1),
		instrs : empty(instruction),
		outputs : empty(int),
	];
	return spec_ctx;
]

fn add_local_type(spec_ctx : spec_context, ctx : context, runtime_type : int) : (spec_context, int)
[
	if runtime_type < 0 then
		return spec_ctx, runtime_type;
	if spec_ctx.lt_map[runtime_type] >= 0 then
		return spec_ctx, spec_ctx.lt_map[runtime_type];
	var lt := ctx.local_types[runtime_type];
	var r := len(spec_ctx.local_types);
	spec_ctx.local_types +<= lt;
	spec_ctx.lt_map[runtime_type] := r;
	if lt is rec then [
		for i := 0 to len(lt.rec.types) do
			spec_ctx, lt.rec.types[i] := add_local_type(spec_ctx, ctx, lt.rec.types[i]);
	] else if lt is arr then [
		spec_ctx, lt.arr := add_local_type(spec_ctx, ctx, lt.arr);
	] else if lt is flat_rec then [
		spec_ctx, lt.flat_rec.non_flat_record := add_local_type(spec_ctx, ctx, lt.flat_rec.non_flat_record);
		for i := 0 to len(lt.flat_rec.flat_types) do
			spec_ctx, lt.flat_rec.flat_types[i] := add_local_type(spec_ctx, ctx, lt.flat_rec.flat_types[i]);
	] else if lt is flat_array then [
		spec_ctx, lt.flat_array.non_flat_array := add_local_type(spec_ctx, ctx, lt.flat_array.non_flat_array);
		spec_ctx, lt.flat_array.flat_entry_type := add_local_type(spec_ctx, ctx, lt.flat_array.flat_entry_type);
	]
	spec_ctx.local_types[r] := lt;
	return spec_ctx, r;
]

fn spec_add_variable_recursive(spec_ctx : spec_context, ctx : context, v : int) : (spec_context, int);

fn add_variable(spec_ctx : spec_context, ctx : context, w : int) : spec_context
[
	var runtime_type type_idx : int;
	spec_ctx, runtime_type := add_local_type(spec_ctx, ctx, ctx.variables[w].runtime_type);
	spec_ctx, type_idx := spec_add_variable_recursive(spec_ctx, ctx, ctx.variables[w].type_index);
	var nv := spec_variable.[
		runtime_type : runtime_type,
		type_idx : type_idx,
	];
	spec_ctx.variables +<= nv;
	return spec_ctx;
]

fn spec_add_variable_recursive(spec_ctx : spec_context, ctx : context, v : int) : (spec_context, int)
[
	if v < 0 then
		return spec_ctx, v;
	var igi := ctx.variables[v].defining_instr;
	var ins := ctx.instrs[igi];
	var opcode := ins.opcode;
	if not allowed_opcodes bt opcode then
		abort exception_make(int, ec_sync, error_user, 0, false);
	var rs := ins.read_set;
	while rs <> 0 do [
		var ridx : int := bsf rs;
		rs btr= ridx;
		var r := ins.params[ridx];
		var nr : int;
		spec_ctx, nr := spec_add_variable_recursive(spec_ctx, ctx, r);
		ins.params[ridx] := nr;
	]
	var ws := ins.write_set;
	var result := -1;
	while ws <> 0 do [
		var widx : int := bsf ws;
		ws btr= widx;
		var w := ins.params[widx];
		spec_ctx := add_variable(spec_ctx, ctx, w);
		ins.params[widx] := len(spec_ctx.variables) - 1;
		if v = w then
			result := len(spec_ctx.variables) - 1;
	]
	if result = -1 then
		abort internal("output variable not found in write set");
	spec_ctx.instrs +<= ins;
	return spec_ctx, result;
]

fn spec_add_variable(spec_ctx : spec_context, ctx : context, a v : int) : spec_context
[
	var o : int;
	spec_ctx.arguments bts= a;
	spec_ctx, o := spec_add_variable_recursive(spec_ctx, ctx, v);
	spec_ctx.outputs +<= o;
	return spec_ctx;
]

fn spec_extract_pcode(spec_ctx : spec_context) : list(pcode_t)
[
	var real_returns := 0;
	for i := 0 to len(spec_ctx.outputs) do [
		var o := spec_ctx.outputs[i];
		if o >= 0,
		   spec_ctx.variables[o].type_idx <> T_Type then
			real_returns += 1;
	]
	var rpc := empty(pcode_t);
	rpc +<= popcnt spec_ctx.arguments;
	var args := spec_ctx.arguments;
	while args <> 0 do [
		var a := bsf args;
		args btr= a;
		rpc +<= a;
	]
	rpc += list(pcode_t).[
		Fn_Function,
		Call_Mode_Inline,
		0,
		len(spec_ctx.local_types),
		len(spec_ctx.variables),
		0,
		len(spec_ctx.outputs),
		real_returns,
		0,
	];
	rpc += blob_store("");
	for i := 0 to len(spec_ctx.local_types) do [
		rpc += dump_local_type(spec_ctx.local_types[i]);
	]
	for i := 0 to len(spec_ctx.variables) do [
		var v := spec_ctx.variables[i];
		rpc += list(pcode_t).[
			v.type_idx,
			v.runtime_type,
			-1,
			0,
		];
		rpc += blob_store("");
	]
	var i1 := instruction.[
		opcode : P_Args,
		params : empty(pcode_t),
	];
	var i2 := instruction.[
		opcode : P_Return_Vars,
		params : empty(pcode_t),
	];
	var i3 := instruction.[
		opcode : P_Return,
		params : empty(pcode_t),
	];
	for i := 0 to len(spec_ctx.outputs) do [
		i2.params +<= spec_ctx.outputs[i];
		i3.params +<= 0;
		i3.params +<= spec_ctx.outputs[i];
	]
	spec_ctx.instrs := [ i1, i2 ] + spec_ctx.instrs + [ i3 ];
	for i := 0 to len(spec_ctx.instrs) do [
		var instr := spec_ctx.instrs[i];
		rpc +<= instr.opcode;
		rpc +<= len(instr.params);
		rpc += instr.params;
	]
	return rpc;
]

fn spec_pcode(pc : list(pcode_t), spec_data : list(pcode_t), un : bytes, get_inline : fn(function, bool) : list(pcode_t), verify_pattern : bytes) : list(pcode_t)
[
	var n_args := spec_data[0];
	var args := 0;
	for i := 0 to n_args do
		args bts= spec_data[1 + i];
	var ptr := 1 + n_args;

	var new_ctx := load_function_context(spec_data[ptr .. ], un, get_inline);

	var ctx := load_function_context(pc, un, get_inline);

	ctx.name += ".spec";

	pc[5] -= n_args;

	var i0 := ctx.blocks[0].instrs[0];
	var instr_args := ctx.instrs[i0];
	if instr_args.opcode <> P_Args then
		abort internal("The function doesn't start with P_Args");
	var instr_args_params := empty(pcode_t);
	var call_result := empty(pcode_t);
	for i := 0 to len(instr_args.params) do [
		if not args bt i then
			instr_args_params +<= instr_args.params[i];
		else
			call_result +<= instr_args.params[i];
	]
	ctx.instrs[i0] := create_instr(P_Args, instr_args_params, 0);

	ctx := do_inline_or_specialize(ctx, new_ctx, 0, 1, 0, empty(pcode_t), call_result);

	ctx.specialize_args := 0;

	pc := process_pcode_ctx(pc, ctx, verify_pattern);

	return pc;
]

fn spec_extract(pc : list(pcode_t)) : treeset(list(pcode_t))
[
	var ptr := 9 + blob_length(pc[9 .. ]);
	for i := 0 to pc[3] do [
		var ft := pc[ptr];
		ptr += 1;
		if ft = Local_Type_Record or ft = Local_Type_Option then [
			ptr += function_specifier_length(pc[ptr .. ]);
			ptr += 1 + pc[ptr];
		] else if ft = Local_Type_Flat_Record then [
			ptr += 2 + pc[ptr + 1];
		] else if ft = Local_Type_Array then [
			ptr += 1;
		] else if ft = Local_Type_Flat_Array then [
			ptr += 3;
		] else [
			abort internal("spec_extract: unknown local type " + ntos(ft));
		]
	]
	for i := 0 to pc[4] do [
		ptr += 4;
		ptr += blob_length(pc[ptr .. ]);
	]
	var specs := treeset_init(list(pcode_t));
	while ptr < len(pc) do [
		var ins := pc[ptr];
		if ins = P_Call then [
			if function_specifier_is_spec(pc[ptr + 5 .. ]) then [
				var l := function_specifier_length(pc[ptr + 5 .. ]);
				specs := treeset_set(specs, pc[ptr + 5 .. ptr + 5 + l]);
			]
		]
		ptr += 2 + pc[ptr + 1];
	]
	if ptr > len(pc) then
		abort internal("spec_extract: pcode doesn't match");
	return specs;
]
