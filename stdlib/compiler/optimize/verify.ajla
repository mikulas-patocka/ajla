{*
 * Copyright (C) 2025 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.optimize.verify;

uses compiler.optimize.defs;

fn verify_function(ctx : context) : unit_type;

implementation

uses exception;
uses charset;
uses z3;
uses compiler.common.blob;
uses compiler.optimize.ssa;

fn allocate_variable(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, v : int, phi_node : int) : (z3_world, context, bytes);

fn get_z3_name(ctx : context, v : int, phi_node : int) : bytes
[
	var n := "var_";
	if phi_node > 0 then
		n += "phi_" + map(ntos_base(phi_node, 16), ascii_locase) + "_";
	n += map(ntos_base(v, 16), ascii_locase);
	if len_greater_than(ctx.variables[v].name, 0) then [
		n += "_" + ctx.variables[v].name;
	]
	return n;
]

fn get_z3_bb_name(ctx : context, bgi : int) : (context, bytes)
[
	var str := "bb_" + map(ntos_base(bgi, 16), ascii_locase);
	ctx.blocks[bgi].block_name := str;
	return ctx, str;
]

fn get_z3_type(ctx : context, type_index : int) : (context, bytes)
[
	if type_index = T_AlwaysFlatOption then
		return ctx, "Bool";
	if type_index <= T_Integer, type_index >= T_Integer128 then
		return ctx, "Int";
	if type_index <= T_Real16, type_index >= T_Real128 then
		return ctx, "Real";
	if len_greater_than(ctx.variables[type_index].type_name, 0) then
		return ctx, ctx.variables[type_index].type_name;
	var ins := ctx.instrs[ctx.variables[type_index].defining_instr];
	if ins.opcode = P_Array_Flexible or ins.opcode = P_Array_Fixed then [
		var t1 := ins.params[1];
		var t1_str : bytes;
		ctx, t1_str := get_z3_type(ctx, t1);
		if not len_greater_than(t1_str, 0) then
			return ctx, "";
		ctx.variables[type_index].type_name := "(Arr " + t1_str + ")";
		return ctx, ctx.variables[type_index].type_name;
	]
	return ctx, "";
]

fn get_array_type(ctx : context, v : int) : (context, bytes)
[
	var type_index := ctx.variables[v].type_index;
	var ins := ctx.instrs[ctx.variables[type_index].defining_instr];
	if ins.opcode = P_Array_Flexible or ins.opcode = P_Array_Fixed then [
		return get_z3_type(ctx, ins.params[1]);
	]
	abort internal("get_array_type: invalid type " + ntos(ins.opcode));
]

fn gen_assert(implicit z3w : z3_world, implicit z3ctx : z3_context, var_name : bytes, ops : bytes) : z3_world
[
	var str := "(assert (= " + var_name + " " + ops + "))";
	z3_eval_smtlib2_string_noret(str);
]

fn allocate_variable_block(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, v : int, phi_node : int, bb : int) : (z3_world, context, bytes)
[
	var ins := ctx.instrs[ctx.variables[v].defining_instr];
	if ins.bb = bb then [
		if ins.opcode = P_Phi, phi_node > 0 then
			return allocate_variable(ctx, ins.params[phi_node], 0);
		return allocate_variable(ctx, v, phi_node);
	] else [
		return allocate_variable(ctx, v, 0);
	]
]

fn assert_instruction(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, v : int, phi_node : int) : (z3_world, context)
[
	var var_name := ctx.variables[v].verifier_name[phi_node];
	var ins := ctx.instrs[ctx.variables[v].defining_instr];
	if ins.opcode = P_BinaryOp or ins.opcode = P_BinaryConstOp then [
		var t := ctx.variables[ins.params[3]].type_index;
		var is_bool := t = T_AlwaysFlatOption;
		var is_int := t <= T_Integer and t >= T_Integer128;
		var is_real := t <= T_Real16 and t >= T_Real128;
		var op_z3 : bytes;
		var op := ins.params[0];
		if op = Bin_Add					then op_z3 := "+";
		else if op = Bin_Subtract			then op_z3 := "-";
		else if op = Bin_Multiply			then op_z3 := "*";
		else if op = Bin_Divide_Int			then op_z3 := "div";
		else if op = Bin_Divide_Real			then op_z3 := "/";
		else if op = Bin_Modulo				then op_z3 := "rem";
		else if op = Bin_And, is_bool			then op_z3 := "and";
		else if op = Bin_Or, is_bool			then op_z3 := "or";
		else if op = Bin_Xor, is_bool			then op_z3 := "xor";
		else if op = Bin_Equal				then op_z3 := "=";
		else if op = Bin_NotEqual			then op_z3 := "distinct";
		else if op = Bin_Less, is_int or is_real	then op_z3 := "<";
		else if op = Bin_LessEqual, is_int or is_real	then op_z3 := "<=";
		else if op = Bin_Greater, is_int or is_real	then op_z3 := ">";
		else if op = Bin_GreaterEqual, is_int or is_real then op_z3 := ">=";
		else if op = Bin_LessEqual, is_bool		then op_z3 := "=>";
		else return ctx;
		var var1 var1v var2 var2v : bytes;
		//eval debug("P_BinaryOp: " + ntos(ins.params[0]) + ", " + ntos(ins.params[1]) + ", " + ntos(ins.params[2]) + ", " + ntos(ins.params[3]) + ", " + ntos(ins.params[4]) + ", " + ntos(ins.params[5]));
		ctx, var1 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		if ins.opcode = P_BinaryOp then [
			ctx, var2 := allocate_variable_block(ctx, ins.params[5], phi_node, ins.bb);
			if len(var2) = 0 then
				return ctx;
			gen_assert(var_name, "(" + op_z3 + " " + var1 + " " + var2 + ")");
		] else [
			if is_bool then
				var2 := select(ins.params[4] <> 0, "false", "true");
			else
				var2 := ntos(ins.params[4]);
			gen_assert(var_name, "(" + op_z3 + " " + var1 + " " + var2 + ")");
		]
		return ctx;
	]
	if ins.opcode = P_UnaryOp then [
		var t := ctx.variables[v].type_index;
		var is_bool := t = T_AlwaysFlatOption;
		var is_int := t <= T_Integer and t >= T_Integer128;
		var is_real := t <= T_Real16 and t >= T_Real128;
		var op_z3 : bytes;
		var op := ins.params[0];
		if op = Un_Not, is_bool				then op_z3 := "not";
		else if op = Un_Neg, is_int or is_real		then op_z3 := "-";
		else return ctx;
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		gen_assert(var_name, "(" + op_z3 + " " + var1 + ")");
		return ctx;
	]
	if ins.opcode = P_Copy then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		gen_assert(var_name, var1);
		return ctx;
	]
	if ins.opcode = P_Load_Const then [
		var cnst : bytes;
		var l := blob_to_int(ins.params[1 ..]);
		var t := ctx.variables[v].type_index;
		if t = T_AlwaysFlatOption then
			cnst := select(l <> 0, "false", "true");
		else if t <= T_Integer and t >= T_Integer128 then
			cnst := ntos(l);
		else
			return ctx;
		gen_assert(var_name, cnst);
		return ctx;
	]
	if ins.opcode = P_Array_Create then [
		var ln := ins.params[2];
		var t1 : bytes;
		ctx, t1 := get_array_type(ctx, v);
		if len(t1) = 0 then
			return ctx;
		var a := "(declare-const array_"+var_name+" (Array Int "+t1+"))";
		z3_eval_smtlib2_string_noret(a);
		var str := "array_"+var_name+"";
		for i := 0 to ln do [
			var var1 : bytes;
			ctx, var1 := allocate_variable_block(ctx, ins.params[5 + i * 2], phi_node, ins.bb);
			if len(var1) = 0 then
				return ctx;
			str := "(store "+str+" "+ntos(i)+" "+var1+")";
		]
		str := "(mk-arr "+ntos(ln)+" "+str+")";
		gen_assert(var_name, str);
		return ctx;
	]
	if ins.opcode = P_Array_Fill then [
		var var1 var2 t1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		ctx, t1 := get_z3_type(ctx, ctx.variables[ins.params[3]].type_index);
		if len(t1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[4], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		gen_assert(var_name, "(mk-arr "+var2+" ((as const (Array Int "+t1+")) "+var1+"))");
		return ctx;
	]
	if ins.opcode = P_Array_Load then [
		var var1 var2 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		var str := "(assert (=> (and (>= "+var2+" 0) (< "+var2+" (arr-len "+var1+"))) (= "+ var_name +" (select (arr "+var1+") "+var2+"))))";
		z3_eval_smtlib2_string_noret(str);
		return ctx;
	]
	if ins.opcode = P_Array_Len then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[1], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		gen_assert(var_name, "(arr-len "+var1+")");
		return ctx;
	]
	if ins.opcode = P_Array_Len_Greater_Than then [
		var var1 var2 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[1], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		gen_assert(var_name, "(> (arr-len "+var1+") "+var2+")");
		return ctx;
	]
	if ins.opcode = P_Array_Flatten then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		gen_assert(var_name, var1);
		return ctx;
	]
	if ins.opcode = P_Return_Vars then [
		var new_v : int;
		for i := 0 to len(ins.params) do [
			if ins.params[i] = v then [
				new_v := ctx.return_ins.params[1 + 2 * i];
				goto found_new_v;
			]
		]
		abort internal("P_Return_Vars parameter not found");
found_new_v:
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, new_v, phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		gen_assert(var_name, var1);
		return ctx;
	]
	//eval debug("unknown opcode: " + ntos(ins.opcode) + " (" + ctx.variables[v].verifier_name[0] + ")");
	return ctx;
]

fn allocate_variable(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, v : int, phi_node : int) : (z3_world, context, bytes)
[
	if not len_greater_than(ctx.variables[v].verifier_name[phi_node], 0) then [
		var t : bytes;
		ctx, t := get_z3_type(ctx, ctx.variables[v].type_index);
		if not len_greater_than(t, 0) then
			return ctx, "";
		var n := get_z3_name(ctx, v, phi_node);
		ctx.variables[v].verifier_name[phi_node] := n;
		z3_eval_smtlib2_string_noret("(declare-const " + n + " " + t + ")");
		ctx := assert_instruction(ctx, v, phi_node);
	]
	return ctx, ctx.variables[v].verifier_name[phi_node];
]

fn verify_function(ctx : context) : unit_type
[
	var b : bytes;
	implicit var z3w := z3_mk_world;
	implicit var z3ctx := z3_mk_context();
	//eval debug("verify function " + ctx.name);

	z3_eval_smtlib2_string_noret("(declare-datatypes (T) ((Arr (mk-arr (arr-len Int) (arr (Array Int T))))))");

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		if len(ctx.blocks[bgi].post_list) = 3 then
			ctx := deactivate_arrow(ctx, bgi, 2);
	]
	ctx := prune_unreachable(ctx);

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		for ili := 0 to len(ctx.blocks[bgi].instrs) do [
			var igi := ctx.blocks[bgi].instrs[ili];
			var ins := ctx.instrs[igi];
			if ins.opcode = P_Return then [
				ctx.return_ins := ins;
			]
		]
		for i := 0 to len(ctx.blocks[bgi].post_list) do [
			var p := ctx.blocks[bgi].post_list[i];
			// TODO: this doesn't eliminate all loops
			if ctx.blocks[p].dominates bt bgi then [
				ctx.blocks[bgi].post_cut_nodes bts= i;
				ctx.blocks[p].pre_cut_nodes := true;
			]
		]
		var str : bytes;
		ctx, str := get_z3_bb_name(ctx, bgi);
		z3_eval_smtlib2_string_noret("(declare-const " + str + " Bool)");
	]

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		for ili := 0 to len(ctx.blocks[bgi].instrs) do [
			var igi := ctx.blocks[bgi].instrs[ili];
			var ins := ctx.instrs[igi];
			if ins.opcode = P_Invariant then [
				if not len_greater_than(ctx.blocks[bgi].pred_list, 0) then [
					var str := "A block with invariant statement has not predecessor in " + ctx.name;
					return exception_make_str(unit_type, ec_async, error_compiler_error, 0, false, str);

				]
				for i := 0 to len(ctx.blocks[bgi].pred_list) do [
					var var1 : bytes;
					ctx, var1 := allocate_variable(ctx, ins.params[0], i + 1);
					if len(var1) = 0 then
						var1 := "false";
					var new_blk := ctx.blocks[bgi].pred_list[i];
					ctx.blocks[new_blk].added_claims +<= var1;
				]
			]
		]
	]

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		var assumes := "";
		var claims := "";
		var guards := "";
		var all_phis := "";
		for i := 0 to len(ctx.blocks[bgi].pred_list) do [
			var p := ctx.blocks[bgi].pred_list[i];
			var guard : bytes;
			if len_greater_than(ctx.blocks[p].instrs, 0) then [
				var ins := ctx.instrs[ctx.blocks[p].instrs[len(ctx.blocks[p].instrs) - 1]];
				if ins.opcode = P_Jmp_False then [
					var pos := ctx.blocks[bgi].pred_position[i];
					var var1 : bytes;
					ctx, var1 := allocate_variable(ctx, ins.params[0], 0);
					if pos = 0 then
						guard := var1;
					else if pos = 1 then
						guard := "(not " + var1 + ")";
					else
						guard := "false";
				] else [
					guard := "true";
				]
			] else [
				guard := "true";
			]
			guards += " " + guard;
			if not ctx.blocks[bgi].pre_cut_nodes then [
				var phis := "";
				for ili := 0 to len(ctx.blocks[bgi].instrs) do [
					var igi := ctx.blocks[bgi].instrs[ili];
					var ins := ctx.instrs[igi];
					if ins.opcode <> P_Phi then
						break;
					var phi1 var1 : bytes;
					ctx, phi1 := allocate_variable(ctx, ins.params[0], 0);
					ctx, var1 := allocate_variable(ctx, ins.params[i + 1], 0);
					phis += " (= " + phi1 + " " + var1 + ")";
				]
				if len_greater_than(phis, 0) then [
					all_phis += " (and" + phis + ")";
				]
			]
		]
		if len_greater_than(all_phis, 0) then
			assumes += " (or" + all_phis + ")";
		if len_greater_than(guards, 0) then
			assumes += " (or" + guards + ")";
		for ili := 0 to len(ctx.blocks[bgi].instrs) do [
			var igi := ctx.blocks[bgi].instrs[ili];
			var ins := ctx.instrs[igi];
			if ins.opcode = P_Assume or ins.opcode = P_Invariant then [
				var var1 : bytes;
				ctx, var1 := allocate_variable(ctx, ins.params[0], 0);
				if len_greater_than(var1, 0) then
					assumes += " " + var1;
			] else if ins.opcode = P_Claim then [
				var var1 : bytes;
				ctx, var1 := allocate_variable(ctx, ins.params[0], 0);
				if len_greater_than(var1, 0) then [
					claims += " " + var1;
				]
			]
		]
		for i := 0 to len(ctx.blocks[bgi].added_claims) do [
			claims += " " + ctx.blocks[bgi].added_claims[i];
		]
		for i := 0 to len(ctx.blocks[bgi].post_list) do [
			if ctx.blocks[bgi].post_cut_nodes bt i then
				continue;
			var p := ctx.blocks[bgi].post_list[i];
			claims += " " + ctx.blocks[p].block_name;
		]
		if len(assumes) = 0 then
			assumes := " true";
		if len(claims) = 0 then
			claims := " true";
		z3_eval_smtlib2_string_noret("(assert (= " + ctx.blocks[bgi].block_name + " (=> (and" + assumes + ") (and" + claims + "))))");
	]

	z3_eval_smtlib2_string_noret("(assert (not " + ctx.blocks[0].block_name + "))");
	b := z3_eval_smtlib2_string("(check-sat)");
	if list_begins_with(b, "unsat") then
		return unit_value;
	if list_begins_with(b, "sat") then [
		b := z3_eval_smtlib2_string("(get-model)");
		b := "Verification of function " + ctx.name + " failed:" + nl + b;
		return exception_make_str(unit_type, ec_async, error_compiler_error, 0, false, b);
	]
	b := "Verification of function " + ctx.name + " inconclusive";
	return exception_make_str(unit_type, ec_async, error_compiler_error, 0, false, b);
]
