{*
 * Copyright (C) 2025 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.optimize.verify;

uses compiler.optimize.defs;

fn verify_function(ctx : context) : unit_type;

implementation

uses exception;
uses charset;
uses z3;
uses compiler.common.blob;
uses compiler.optimize.ssa;

fn z3_eval(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, str : bytes) : (z3_world, bytes)
[
	if ctx.dump_z3, not is_exception z3w then
		eval debug(str);
	var b := z3_eval_smtlib2_string(str);
	if is_exception z3w then
		abort internal("z3 failed on line """ + str + """: """ + exception_string z3w + """ (" + ctx.name + ")");
	return b;
]

fn z3_eval_noret(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, str : bytes) : z3_world
[
	if ctx.dump_z3, not is_exception z3w then
		eval debug(str);
	z3_eval_smtlib2_string_noret(str);
	if is_exception z3w then
		abort internal("z3 failed on line """ + str + """: """ + exception_string z3w + """ (" + ctx.name + ")");
]

fn allocate_variable(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, v : int, phi_node : int) : (z3_world, context, bytes);

fn get_z3_name(ctx : context, v : int, phi_node : int) : bytes
[
	var n := "var_";
	if phi_node > 0 then
		n += "phi_" + map(ntos_base(phi_node, 16), ascii_locase) + "_";
	n += map(ntos_base(v, 16), ascii_locase);
	if len_greater_than(ctx.variables[v].name, 0) then [
		n += "_" + ctx.variables[v].name;
	]
	return n;
]

fn get_z3_bb_name(ctx : context, bgi : int) : (context, bytes)
[
	var str := "bb_" + map(ntos_base(bgi, 16), ascii_locase);
	ctx.blocks[bgi].block_name := str;
	return ctx, str;
]

fn get_nonflat_lt(ctx : context, runtime_type : int) : int
[
	if runtime_type < 0 then
		return runtime_type;
	var lt := ctx.local_types[runtime_type];
	if lt is flat_rec then
		return lt.flat_rec.non_flat_record;
	if lt is flat_array then [
		abort;		// !!! TODO: flat array
	]
	return runtime_type;
]

fn get_array_subtype(lt : local_type) : int
[
	if lt is flat_array then
		return lt.flat_array.flat_entry_type;
	return lt.arr;
]

fn get_bv_width(runtime_type : int) := 8 shl ((T_SInt8 - runtime_type) shr 1);

fn get_z3_type(ctx : context, runtime_type : int) : bytes
[
	if runtime_type = T_Bool then
		return "Bool";
	if runtime_type <= T_Integer, runtime_type >= T_Integer128 then
		return "Int";
	if runtime_type <= T_Real16, runtime_type >= T_Real128 then
		return "Real";
	if runtime_type = T_Undetermined then
		return "Undetermined";
	if runtime_type <= T_SInt8, runtime_type >= T_UInt128 then [
		return "(_ BitVec " + ntos(get_bv_width(runtime_type)) + ")";
	]
	if runtime_type < 0 then
		abort internal("get_z3_type: invalid type " + ntos(runtime_type));
	if len_greater_than(ctx.local_type_names[runtime_type], 0) then
		return ctx.local_type_names[runtime_type];
	var lt := ctx.local_types[runtime_type];
	if lt is flat_array then
		return get_z3_type(ctx, lt.flat_array.non_flat_array);
	if lt is flat_rec then
		return get_z3_type(ctx, lt.flat_rec.non_flat_record);
	abort internal("get_z3_type: invalid loacl type " + ntos(ord lt));
]

fn str_array_len(ctx : context, runtime_type : int) : bytes
[
	return "len-LT_" + ntos_base(runtime_type, 16);
]

fn str_array_content(ctx : context, runtime_type : int) : bytes
[
	return "content-LT_" + ntos_base(runtime_type, 16);
]

fn str_array_make(ctx : context, runtime_type : int) : bytes
[
	return "mk-LT_" + ntos_base(runtime_type, 16);
]

fn get_array_type(ctx : context, v : int) : bytes
[
	var lt := ctx.local_types[ctx.variables[v].runtime_type];
	if lt is arr or lt is flat_array then
		return get_z3_type(ctx, get_array_subtype(lt));
	abort internal("get_array_type: invalid type " + ntos(ord lt));
]

fn gen_assert(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, var_name : bytes, ops : bytes) : z3_world
[
	var str := "(assert (= " + var_name + " " + ops + "))";
	z3_eval_noret(ctx, str);
]

fn allocate_variable_block(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, v : int, phi_node : int, bb : int) : (z3_world, context, bytes)
[
	var ins := ctx.instrs[ctx.variables[v].defining_instr];
	if ins.bb = bb then [
		if ins.opcode = P_Phi, phi_node > 0 then
			return allocate_variable(ctx, ins.params[phi_node], 0);
		return allocate_variable(ctx, v, phi_node);
	] else [
		return allocate_variable(ctx, v, 0);
	]
]

fn declare_variable(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, n : bytes, lt : int) : (z3_world, context)
[
	var t := get_z3_type(ctx, lt);
	z3_eval_noret(ctx, "(declare-const " + n + " " + t + ")");
	if lt >= 0 then [
		if ctx.local_types[lt] is rec then [
			if not ctx.local_types[lt].rec.opt then
				z3_eval_noret(ctx, "(assert ((_ is mk-"+t+") "+n+"))");
		] else if ctx.local_types[lt] is arr or ctx.local_types[lt] is flat_array then [
			z3_eval_noret(ctx, "(assert (>= ("+str_array_len(ctx, lt)+" "+n+") 0))");
		]
	]
	return ctx;
]

fn get_bv_const(typ : int, num : int) : bytes
[
	var hex_width := 2 shl ((T_SInt8 - typ) shr 1);
	if num < 0 then
		num += 1 shl (hex_width shl 2);
	return "#x" + list_left_pad(ntos_base(num, 16), hex_width, '0');
]

fn get_z3_operator(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, typ : int, op : int) : (z3_world, context, bytes, bool)
[
	if len(ctx.op_map[-typ, op]) <> 0 then
		return ctx, ctx.op_map[-typ, op], ctx.unint_map[-typ, op];
	var str := "";
	var unint := false;
	if typ <= T_SInt8, typ >= T_UInt128 then [
		var us := T_SInt8 - typ bt 0;
		if op = Bin_Add				then str := "bvadd";
		else if op = Bin_Subtract		then str := "bvsub";
		else if op = Bin_Multiply		then str := "bvmul";
		else if op = Bin_Divide_Int, not us	then str := "bvsdiv";
		else if op = Bin_Divide_Int, us		then str := "bvudiv";
		else if op = Bin_Modulo, not us		then str := "bvsmod";
		else if op = Bin_Modulo, us		then str := "bvurem";
		else if op = Bin_And			then str := "bvand";
		else if op = Bin_Or			then str := "bvor";
		else if op = Bin_Xor			then str := "bvxor";
		else if op = Bin_Shl			then str := "bvshl";
		else if op = Bin_Shr, not us		then str := "bvashr";
		else if op = Bin_Shr, us		then str := "bvlshr";
		else if op = Bin_Rol			then str := "ext_rotate_left";
		else if op = Bin_Ror			then str := "ext_rotate_right";
		else if op = Bin_Equal			then str := "=";
		else if op = Bin_NotEqual		then str := "distinct";
		else if op = Bin_Less, not us		then str := "bvslt";
		else if op = Bin_LessEqual, not us	then str := "bvsle";
		else if op = Bin_Greater, not us	then str := "bvsgt";
		else if op = Bin_GreaterEqual, not us	then str := "bvsge";
		else if op = Bin_Less, us		then str := "bvult";
		else if op = Bin_LessEqual, us		then str := "bvule";
		else if op = Bin_Greater, us		then str := "bvugt";
		else if op = Bin_GreaterEqual, us	then str := "bvuge";
		else if op = Un_Not			then str := "bvnot";
		else if op = Un_Neg			then str := "bvneg";
		else if op = Un_ConvertToInt, not us	then [
								var width := get_bv_width(typ);
								str := "bv-to-int-s" + ntos(width);
								var t := get_z3_type(ctx, typ);
								z3_eval_noret(ctx, "(define-fun "+str+" ((x "+t+")) Int (ite (bvsge x "+get_bv_const(typ, 0)+") (bv2int x) (- (bv2int x) "+ntos(0 bts width)+")))");
							]
		else if op = Un_ConvertToInt, us	then str := "bv2int";
		else if op = Un_ConvertFromInt		then [
								var width := get_bv_width(typ);
								str := "bv-from-int-" + select(us, "s", "us") + ntos(width);
								unint := true;
								var t := get_z3_type(ctx, typ);
								var lb := 0;
								var ub := 0 bts width;
								if not us then [
									lb -= 0 bts width - 1;
									ub -= 0 bts width - 1;
								]
								z3_eval_noret(ctx, "(define-fun "+str+" ((x Int) (unint "+t+")) "+t+" (ite (and (>= x "+ntos(lb)+") (< x "+ntos(ub)+")) ((_ int2bv "+ntos(width)+") x) unint))");
							]
	] else if typ <= T_Integer, typ >= T_Integer128 then [
		if op = Bin_Add			then str := "+";
		else if op = Bin_Subtract	then str := "-";
		else if op = Bin_Multiply	then str := "*";
		else if op = Bin_Divide_Int	then str := "div";
		else if op = Bin_Modulo		then str := "rem";
		else if op = Bin_Power		then [ str := "int-power"; unint := true; ]
		else if op = Bin_Bts		then [ str := "int-bts"; unint := true; ]
		else if op = Bin_Btr		then [ str := "int-btr"; unint := true; ]
		else if op = Bin_Btc		then [ str := "int-btc"; unint := true; ]
		else if op = Bin_Equal		then str := "=";
		else if op = Bin_NotEqual	then str := "distinct";
		else if op = Bin_Less		then str := "<";
		else if op = Bin_LessEqual	then str := "<=";
		else if op = Bin_Greater	then str := ">";
		else if op = Bin_GreaterEqual	then str := ">=";
		else if op = Bin_Bt		then [ str := "int-bt"; unint := true; ]
		else if op = Un_Not		then str := "int-not";
		else if op = Un_Neg		then str := "-";
		else if op = Un_ConvertToInt	then str := "+";
		else if op = Un_ConvertFromInt	then str := "+";
	] else if typ <= T_Real16, typ >= T_Real128 then [
		if op = Bin_Add			then str := "+";
		else if op = Bin_Subtract	then str := "-";
		else if op = Bin_Multiply	then str := "*";
		else if op = Bin_Divide_Real	then str := "/";
		else if op = Bin_Modulo		then str := "rem";
		else if op = Bin_Power		then str := "^";
		else if op = Bin_Equal		then str := "=";
		else if op = Bin_NotEqual	then str := "distinct";
		else if op = Bin_Less		then str := "<";
		else if op = Bin_LessEqual	then str := "<=";
		else if op = Bin_Greater	then str := ">";
		else if op = Bin_GreaterEqual	then str := ">=";
		else if op = Un_Neg		then str := "-";
		else if op = Un_Sin		then str := "sin";
		else if op = Un_Cos		then str := "cos";
		else if op = Un_Tan		then str := "tan";
		else if op = Un_Asin		then str := "asin";
		else if op = Un_Acos		then str := "acos";
		else if op = Un_Atan		then str := "atan";
		else if op = Un_Sinh		then str := "sinh";
		else if op = Un_Cosh		then str := "cosh";
		else if op = Un_Tanh		then str := "tanh";
		else if op = Un_Asinh		then str := "asinh";
		else if op = Un_Acosh		then str := "acosh";
		else if op = Un_Atanh		then str := "atanh";
		else if op = Un_ConvertToInt	then str := "real-to-int";
		else if op = Un_ConvertFromInt	then str := "to_real";
	] else if typ = T_Bool then [
		if op = Bin_And			then str := "and";
		else if op = Bin_Or		then str := "or";
		else if op = Bin_Xor		then str := "distinct";
		else if op = Bin_Equal		then str := "=";
		else if op = Bin_NotEqual	then str := "distinct";
		else if op = Bin_LessEqual	then str := "=>";
		else if op = Un_Not		then str := "not";
	] else [
		abort internal("get_z3_operator: invalid type " + ntos(typ));
	]

	ctx.op_map[-typ, op] := str;
	ctx.unint_map[-typ, op] := unint;
	return ctx, str, unint;
]

fn assert_instruction(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, v : int, phi_node : int) : (z3_world, context)
[
	var var_name := ctx.variables[v].verifier_name[phi_node];
	var ins := ctx.instrs[ctx.variables[v].defining_instr];
	if ins.opcode = P_BinaryOp or ins.opcode = P_BinaryConstOp then [
		var t := ctx.variables[ins.params[3]].runtime_type;
		var op_z3 : bytes;
		var unint : bool;
		ctx, op_z3, unint := get_z3_operator(ctx, t, ins.params[0]);
		if len(op_z3) = 0 then
			return ctx;
		var var1 var1v var2 var2v : bytes;
		//eval debug("P_BinaryOp: " + ntos(ins.params[0]) + ", " + ntos(ins.params[1]) + ", " + ntos(ins.params[2]) + ", " + ntos(ins.params[3]) + ", " + ntos(ins.params[4]) + ", " + ntos(ins.params[5]));
		ctx, var1 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var unint_str := "";
		if unint then [
			unint_str := "unint_" + ntos_base(ctx.unint_counter, 16);
			ctx.unint_counter += 1;
			ctx := declare_variable(ctx, unint_str, ctx.variables[v].runtime_type);
			unint_str := " " + unint_str;
		]
		if ins.opcode = P_BinaryOp then [
			ctx, var2 := allocate_variable_block(ctx, ins.params[5], phi_node, ins.bb);
			if len(var2) = 0 then
				return ctx;
			gen_assert(ctx, var_name, "(" + op_z3 + " " + var1 + " " + var2 + unint_str + ")");
		] else [
			if t = T_Bool then
				var2 := select(ins.params[4] <> 0, "false", "true");
			else if t <= T_SInt8, t >= T_UInt128 then
				var2 := get_bv_const(t, ins.params[4]);
			else
				var2 := ntos(ins.params[4]);
			gen_assert(ctx, var_name, "(" + op_z3 + " " + var1 + " " + var2 + unint_str + ")");
		]
		return ctx;
	]
	if ins.opcode = P_UnaryOp then [
		var t := ctx.variables[v].runtime_type;
		if ins.params[0] = Un_ConvertToInt then
			t := ctx.variables[ins.params[3]].runtime_type;
		var op_z3 : bytes;
		var unint : bool;
		ctx, op_z3, unint := get_z3_operator(ctx, t, ins.params[0]);
		if len(op_z3) = 0 then
			return ctx;
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var unint_str := "";
		if unint then [
			unint_str := "unint_" + ntos_base(ctx.unint_counter, 16);
			ctx.unint_counter += 1;
			ctx := declare_variable(ctx, unint_str, ctx.variables[v].runtime_type);
			unint_str := " " + unint_str;
		]
		gen_assert(ctx, var_name, "(" + op_z3 + " " + var1 + unint_str + ")");
		return ctx;
	]
	if ins.opcode = P_Copy then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		gen_assert(ctx, var_name, var1);
		return ctx;
	]
	if ins.opcode = P_Load_Const then [
		var cnst : bytes;
		var l := blob_to_int(ins.params[1 ..]);
		var t := ctx.variables[v].runtime_type;
		if t = T_Bool then [
			cnst := select(l <> 0, "false", "true");
		] else if t <= T_SInt8, t >= T_UInt128 then [
			cnst := get_bv_const(t, l);
		] else if t <= T_Integer and t >= T_Integer128 then [
			cnst := ntos(l);
		] else if t <= T_Real16, t >= T_Real128 then [
			var ex_bits sig_bits : int;
			if t = T_Real16 then ex_bits, sig_bits := 5, 11;
			else if t = T_Real32 then ex_bits, sig_bits := 8, 24;
			else if t = T_Real64 then ex_bits, sig_bits := 11, 53;
			else if t = T_Real80 then ex_bits, sig_bits := 15, 64;
			else if t = T_Real128 then ex_bits, sig_bits := 15, 113;
			else abort internal("assert_instruction: invalid real type " + ntos(t));
			const eb, sb := ex_bits, sig_bits;
			var f := floating_from_internal(eb, sb, l);
			var r : rational := f;
			cnst := "(/ " + ntos(r.num) + " " + ntos(r.den) + ")";
		] else if t >= 0, ctx.local_types[t] is rec, ctx.local_types[t].rec.opt then [
			cnst := "mk-"+ctx.local_type_names[t]+"-"+ntos(l);
		] else [
			return ctx;
		]
		gen_assert(ctx, var_name, cnst);
		return ctx;
	]
	if ins.opcode = P_Structured_Write then [
		var n_steps := ins.params[0];
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var lti := get_nonflat_lt(ctx, ctx.variables[ins.params[3]].runtime_type);
		var idx := 6;
		var idxs := [ idx ];
		var ltis := [ lti ];
		var old_var := var1;
		for i := 0 to n_steps - 1 do [
			var new_var := var_name + "-ld-" + ntos(i + 1);
			var stored_var := var_name + "-st-" + ntos(i + 1);
			if ins.params[idx] = Structured_Record then [
				var t1 := get_z3_type(ctx, lti);
				var slot := ins.params[idx + 1];
				lti := ctx.local_types[lti].rec.types[slot];
				ctx := declare_variable(ctx, new_var, lti);
				ctx := declare_variable(ctx, stored_var, lti);
				var str := "(assert (= "+new_var+" (entry-"+t1+"-"+ntos(slot)+" "+old_var+")))";
				z3_eval_noret(ctx, str);
				idx += 2;
			] else if ins.params[idx] = Structured_Option then [
				var t1 := get_z3_type(ctx, lti);
				var slot := ins.params[idx + 1];
				lti := ctx.local_types[lti].rec.types[slot];
				ctx := declare_variable(ctx, new_var, lti);
				ctx := declare_variable(ctx, stored_var, lti);
				var str := "(assert (= "+new_var+" (entry-"+t1+"-"+ntos(slot)+" "+old_var+")))";
				z3_eval_noret(ctx, str);
				idx += 2;
			] else if ins.params[idx] = Structured_Array then [
				var var2 : bytes;
				ctx, var2 := allocate_variable_block(ctx, ins.params[idx + 1], phi_node, ins.bb);
				if len(var2) = 0 then
					return ctx;
				var olti := lti;
				lti := get_array_subtype(ctx.local_types[lti]);
				ctx := declare_variable(ctx, new_var, lti);
				ctx := declare_variable(ctx, stored_var, lti);
				var str := "(assert (=> (and (>= "+var2+" 0) (< "+var2+" ("+str_array_len(ctx, olti)+" "+old_var+"))) (= "+new_var+" (select ("+str_array_content(ctx, olti)+" "+old_var+") "+var2+"))))";
				z3_eval_noret(ctx, str);
				idx += 2;
			] else [
				abort internal("assert_instruction: invalid structured type " + ntos(ins.params[idx]));
			]
			idxs +<= idx;
			ltis +<= lti;
			old_var := new_var;
		]
		var svar : bytes;
		ctx, svar := allocate_variable_block(ctx, ins.params[5], phi_node, ins.bb);
		if len(svar) = 0 then
			return ctx;
		var i := n_steps - 1;
		while i >= 0 do [
			var new_var : bytes;
			if i = 0 then
				new_var := var_name;
			else
				new_var := var_name + "-st-" + ntos(i);
			var idx := idxs[i];
			var lti := ltis[i];
			if ins.params[idx] = Structured_Record then [
				var t1 := get_z3_type(ctx, lti);
				var slot := ins.params[idx + 1];
				var str := "(assert (= "+new_var+" ((_ update-field entry-"+t1+"-"+ntos(slot)+") "+old_var+" "+svar+")))";
				z3_eval_noret(ctx, str);
			] else if ins.params[idx] = Structured_Option then [
				var t1 := get_z3_type(ctx, lti);
				var slot := ins.params[idx + 1];
				var str := "(assert (= "+new_var+" (mk-"+t1+"-"+ntos(slot)+" "+svar+")))";
				z3_eval_noret(ctx, str);
			] else if ins.params[idx] = Structured_Array then [
				var var2 : bytes;
				ctx, var2 := allocate_variable_block(ctx, ins.params[idx + 1], phi_node, ins.bb);
				if len(var2) = 0 then
					return ctx;
				var str := "(assert (=> (and (>= "+var2+" 0) (< "+var2+" ("+str_array_len(ctx, lti)+" "+old_var+"))) (= ("+str_array_content(ctx, lti)+" "+new_var+") (store ("+str_array_content(ctx, lti)+" "+old_var+") "+var2+" "+svar+"))))";
				z3_eval_noret(ctx, str);
				str := "(assert (=> (and (>= "+var2+" 0) (< "+var2+" ("+str_array_len(ctx, lti)+" "+old_var+"))) (= ("+str_array_len(ctx, lti)+" "+new_var+") ("+str_array_len(ctx, lti)+" "+old_var+"))))";
				z3_eval_noret(ctx, str);
			] else [
				abort internal("assert_instruction: invalid structured type " + ntos(ins.params[idx]));
			]
			if i > 1 then
				old_var := var_name + "-ld-" + ntos(i - 1);
			else
				old_var := var1;
			svar := new_var;
			i -= 1;
		]
		return ctx;
	]
	if ins.opcode = P_Record_Create then [
		var lti := get_nonflat_lt(ctx, ctx.variables[v].runtime_type);
		var lt := ctx.local_types[lti];
		var name := ctx.local_type_names[lti];
		var str : bytes;
		if len(lt.rec.types) = 0 then [
			str := "mk-"+name;
		] else [
			str := "(mk-"+name;
			for i := 0 to len(lt.rec.types) do [
				var var1 : bytes;
				ctx, var1 := allocate_variable_block(ctx, ins.params[3 + i * 2], phi_node, ins.bb);
				if len(var1) = 0 then
					return ctx;
				str += " "+var1;
			]
			str += ")";
		]
		gen_assert(ctx, var_name, str);
		return ctx;
	]
	if ins.opcode = P_Record_Load then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var t1 := get_z3_type(ctx, ctx.variables[ins.params[2]].runtime_type);
		var slot := ins.params[3];
		var str := "(entry-"+t1+"-"+ntos(slot)+" "+var1+")";
		gen_assert(ctx, var_name, str);
		return ctx;
	]
	if ins.opcode = P_Option_Create then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var name := ctx.local_type_names[ctx.variables[v].runtime_type];
		var index := ins.params[1];
		var str := "(mk-"+name+"-"+ntos(index)+" "+var1+")";
		gen_assert(ctx, var_name, str);
		return ctx;
	]
	if ins.opcode = P_Option_Load then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var t1 := get_z3_type(ctx, ctx.variables[ins.params[2]].runtime_type);
		var index := ins.params[3];
		var str := "(entry-"+t1+"-"+ntos(index)+" "+var1+")";
		gen_assert(ctx, var_name, str);
		return ctx;
	]
	if ins.opcode = P_Option_Test then [
		var t := ctx.variables[ins.params[1]].runtime_type;
		var lt := ctx.local_types[t];
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[1], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var index := ins.params[2];
		var str : bytes;
		//var b := get_z3_type(ctx, lt.rec.types[index]);
		//str := "(not (forall ((x "+b+")) (distinct "+var1+" (mk-"+ctx.local_type_names[t]+"-"+ntos(index)+" x))))";
		str := "((_ is mk-"+ctx.local_type_names[t]+"-"+ntos(index)+") "+var1+")";
		gen_assert(ctx, var_name, str);
		return ctx;
	]
	if ins.opcode = P_Option_Ord then [
		var t := ctx.variables[ins.params[1]].runtime_type;
		var lt := ctx.local_types[t];
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[1], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var str := "";
		for i := 0 to len(lt.rec.types) do [
			str += "(ite ((_ is mk-"+ctx.local_type_names[t]+"-"+ntos(i)+") "+var1+") "+ntos(i)+" ";
		]
		str += "-1";
		str += fill(byte, ')', len(lt.rec.types));
		gen_assert(ctx, var_name, str);
		return ctx;
	]
	if ins.opcode = P_Array_Create then [
		var ln := ins.params[1];
		var lt := get_nonflat_lt(ctx, ctx.variables[v].runtime_type);
		var a := "(declare-const array-"+var_name+" LT_"+ntos_base(lt, 16)+")";
		z3_eval_noret(ctx, a);
		var str := "("+str_array_content(ctx, lt)+" array-"+var_name+")";
		for i := 0 to ln do [
			var var1 : bytes;
			ctx, var1 := allocate_variable_block(ctx, ins.params[4 + i * 2], phi_node, ins.bb);
			if len(var1) = 0 then
				return ctx;
			str := "(store "+str+" "+ntos(i)+" "+var1+")";
		]
		str := "("+str_array_make(ctx, lt)+" "+ntos(ln)+" "+str+")";
		gen_assert(ctx, var_name, str);
		return ctx;
	]
	if ins.opcode = P_Array_Fill then [
		var var1 var2 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var t1 := get_z3_type(ctx, ctx.variables[ins.params[2]].runtime_type);
		if len(t1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		var lt := get_nonflat_lt(ctx, ctx.variables[v].runtime_type);
		gen_assert(ctx, var_name, "("+str_array_make(ctx, lt)+" "+var2+" ((as const (Array Int "+t1+")) "+var1+"))");
		return ctx;
	]
	if ins.opcode = P_Array_Load then [
		var var1 var2 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		var lt := get_nonflat_lt(ctx, ctx.variables[ins.params[2]].runtime_type);
		var str := "(assert (=> (and (>= "+var2+" 0) (< "+var2+" ("+str_array_len(ctx, lt)+" "+var1+"))) (= "+var_name+" (select ("+str_array_content(ctx, lt)+" "+var1+") "+var2+"))))";
		z3_eval_noret(ctx, str);
		return ctx;
	]
	if ins.opcode = P_Array_Len then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[1], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		var lt := get_nonflat_lt(ctx, ctx.variables[ins.params[1]].runtime_type);
		gen_assert(ctx, var_name, "("+str_array_len(ctx, lt)+" "+var1+")");
		return ctx;
	]
	if ins.opcode = P_Array_Len_Greater_Than then [
		var var1 var2 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[1], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		var lt := get_nonflat_lt(ctx, ctx.variables[ins.params[1]].runtime_type);
		gen_assert(ctx, var_name, "(> ("+str_array_len(ctx, lt)+" "+var1+") "+var2+")");
		return ctx;
	]
	if ins.opcode = P_Array_Sub or ins.opcode = P_Array_Skip then [
		var var1 var2 var3 t1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[3], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		var lt := get_nonflat_lt(ctx, ctx.variables[ins.params[2]].runtime_type);
		if ins.opcode = P_Array_Sub then [
			ctx, var3 := allocate_variable_block(ctx, ins.params[4], phi_node, ins.bb);
			if len(var3) = 0 then
				return ctx;
		] else [
			var3 := "("+str_array_len(ctx, lt)+" "+var1+")";
		]
		var str := "(assert (=> (and (<= 0 "+var2+") (<= "+var2+" "+var3+") (<= "+var3+" ("+str_array_len(ctx, lt)+" "+var1+"))) (and (= ("+str_array_len(ctx, lt)+" "+var_name+") (- "+var3+" "+var2+")) (forall ((i Int)) (=> (and (>= i "+var2+") (< i "+var3+")) (= (select ("+str_array_content(ctx, lt)+" "+var1+") i) (select ("+str_array_content(ctx, lt)+" "+var_name+") (- i "+var2+"))))))))";
		z3_eval_noret(ctx, str);
		return ctx;
	]
	if ins.opcode = P_Array_Append then [
		var var1 var2 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[4], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		var lt := get_nonflat_lt(ctx, ctx.variables[ins.params[2]].runtime_type);
		var str := "(assert (= ("+str_array_len(ctx, lt)+" "+var_name+") (+ ("+str_array_len(ctx, lt)+" "+var1+") ("+str_array_len(ctx, lt)+" "+var2+"))))";
		z3_eval_noret(ctx, str);
		str := "(assert (forall ((i Int)) (=> (and (>= i 0) (< i ("+str_array_len(ctx, lt)+" "+var1+"))) (= (select ("+str_array_content(ctx, lt)+" "+var1+") i) (select ("+str_array_content(ctx, lt)+" "+var_name+") i)))))";
		z3_eval_noret(ctx, str);
		str := "(assert (forall ((i Int)) (=> (and (>= i 0) (< i ("+str_array_len(ctx, lt)+" "+var2+"))) (= (select ("+str_array_content(ctx, lt)+" "+var2+") i) (select ("+str_array_content(ctx, lt)+" "+var_name+") (+ i ("+str_array_len(ctx, lt)+" "+var1+")))))))";
		z3_eval_noret(ctx, str);
		return ctx;
	]
	if ins.opcode = P_Array_Append_One then [
		var var1 var2 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		ctx, var2 := allocate_variable_block(ctx, ins.params[4], phi_node, ins.bb);
		if len(var2) = 0 then
			return ctx;
		var lt := get_nonflat_lt(ctx, ctx.variables[ins.params[2]].runtime_type);
		var str := "(assert (= ("+str_array_len(ctx, lt)+" "+var_name+") (+ ("+str_array_len(ctx, lt)+" "+var1+") 1)))";
		z3_eval_noret(ctx, str);
		str := "(assert (= ("+str_array_content(ctx, lt)+" "+var_name+") (store ("+str_array_content(ctx, lt)+" "+var1+") ("+str_array_len(ctx, lt)+" "+var1+") "+var2+")))";
		z3_eval_noret(ctx, str);
		return ctx;
	]
	if ins.opcode = P_Array_Flatten then [
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, ins.params[2], phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		gen_assert(ctx, var_name, var1);
		return ctx;
	]
	if ins.opcode = P_Return_Vars then [
		var new_v : int;
		for i := 0 to len(ins.params) do [
			if ins.params[i] = v then [
				new_v := ctx.return_ins.params[1 + 2 * i];
				goto found_new_v;
			]
		]
		abort internal("P_Return_Vars parameter not found");
found_new_v:
		var var1 : bytes;
		ctx, var1 := allocate_variable_block(ctx, new_v, phi_node, ins.bb);
		if len(var1) = 0 then
			return ctx;
		gen_assert(ctx, var_name, var1);
		return ctx;
	]
	//eval debug("unknown opcode: " + ntos(ins.opcode) + " (" + ctx.variables[v].verifier_name[0] + ")");
	return ctx;
]

fn allocate_variable(implicit z3w : z3_world, implicit z3ctx : z3_context, ctx : context, v : int, phi_node : int) : (z3_world, context, bytes)
[
	if not len_greater_than(ctx.variables[v].verifier_name[phi_node], 0) then [
		var n := get_z3_name(ctx, v, phi_node);
		ctx.variables[v].verifier_name[phi_node] := n;
		ctx := declare_variable(ctx, n, ctx.variables[v].runtime_type);
		ctx := assert_instruction(ctx, v, phi_node);
	]
	return ctx, ctx.variables[v].verifier_name[phi_node];
]

fn verify_function(ctx : context) : unit_type
[
	implicit var z3w := z3_mk_world;
	implicit var z3ctx := z3_mk_context();

	ctx.op_map := array_fill("", [ -T_Bool + 1, Op_N ]);
	ctx.unint_map := array_fill(false, [ -T_Bool + 1, Op_N ]);
	ctx.unint_counter := 0;
	var d := get_dump("z3");
	ctx.dump_z3 := d = "*" or d = ctx.name;

	{if ctx.name = "dump_basic_blocks" or
	   ctx.name = "menu_process_event" then
		return unit_value;}

	if ctx.dump_z3 then
		eval debug("verify function " + ctx.name);

	z3_eval_noret(ctx, "(declare-sort Undetermined 0)");

	var str := "(declare-datatypes (";
	var first := true;
	for lti := 0 to len(ctx.local_types) do [
		var lt := ctx.local_types[lti];
		if lt is flat_array or lt is flat_rec then
			continue;
		if not first then
			str += " ";
		first := false;
		var name := "LT_" + ntos_base(lti, 16);
		if lt is rec then
			name += "-" + lt.rec.name;
		ctx.local_type_names[lti] := name;
		str += "(" + name + " 0)";
		//eval debug("NAME: " + name);
	]
	str += ") (";
	first := true;
	for lti := 0 to len(ctx.local_types) do [
		var lt := ctx.local_types[lti];
		if lt is flat_array or lt is flat_rec then
			continue;
		if not first then
			str += " ";
		first := false;
		var name := ctx.local_type_names[lti];
		if lt is arr then [
			str += "(" + name + " (mk-" + name + " (" + str_array_len(ctx, lti) + " Int) (" + str_array_content(ctx, lti) + " (Array Int ";
			var b := get_z3_type(ctx, lt.arr);
			str += b + "))))";
			continue;
		]
		var ltr := lt.rec;
		if not ltr.opt then [
			str += "(" + name + " (mk-" + name;
			for i := 0 to len(ltr.types) do [
				if ltr.types[i] = T_Type then
					continue;
				var b := get_z3_type(ctx, ltr.types[i]);
				str += " (entry-" + name + "-" + ntos(i) + " " + b + ")";
			]
			str += "))";
		] else [
			str += "(" + name;
			for i := 0 to len(ltr.types) do [
				str += " (mk-" + name + "-" + ntos(i);
				if ltr.types[i] <> T_EmptyOption then [
					//eval debug("OPT: " + ntos(ltr.types[i]));
					var b := get_z3_type(ctx, ltr.types[i]);
					str += " (entry-" + name + "-" + ntos(i) + " " + b + ")";
				]
				str += ")";
			]
			str += ")";
		]
	]
	str += "))";
	z3_eval_noret(ctx, str);

	z3_eval_noret(ctx, "(define-fun int-power ((x Int) (y Int) (unint Int)) Int (ite (< y 0) unint (to_int (^ x y))))");
	z3_eval_noret(ctx, "(define-fun int-bt ((x Int) (y Int) (unint Bool)) Bool (ite (< y 0) unint (>= (mod x (^ 2 (+ y 1))) (^ 2 y))))");
	z3_eval_noret(ctx, "(define-fun int-bts ((x Int) (y Int) (unint Int)) Int (ite (< y 0) unint (ite (int-bt x y false) x (+ x (to_int (^ 2 y))))))");
	z3_eval_noret(ctx, "(define-fun int-btr ((x Int) (y Int) (unint Int)) Int (ite (< y 0) unint (ite (int-bt x y false) (- x (to_int (^ 2 y))) x)))");
	z3_eval_noret(ctx, "(define-fun int-btc ((x Int) (y Int) (unint Int)) Int (ite (< y 0) unint (ite (int-bt x y false) (- x (to_int (^ 2 y))) (+ x (to_int (^ 2 y))))))");
	z3_eval_noret(ctx, "(define-fun int-not ((x Int)) Int (- (- x) 1))");

	z3_eval_noret(ctx, "(define-fun real-to-int ((x Real)) Int (ite (>= x 0) (to_int x) (- (to_int (- x)))))");

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		if len(ctx.blocks[bgi].post_list) = 3 then
			ctx := deactivate_arrow(ctx, bgi, 2);
	]
	ctx := prune_unreachable(ctx);

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		var b := bgi;
		while b <> 0 do [
			var bb := ctx.blocks[b].idom;
			if len(ctx.blocks[bb].post_list) = 2,
			   ctx.blocks[bb].post_list[0] = b xor ctx.blocks[bb].post_list[1] = b then [
				var ins := ctx.instrs[ctx.blocks[bb].instrs[len(ctx.blocks[bb].instrs) - 1]];
				if ins.opcode <> P_Jmp_False then
					abort internal("immediate dominator does not end with P_Jmp_False");
				if ctx.blocks[bb].post_list[0] = b then
					ctx.blocks[b].guards bts= ins.params[0];
				else
					ctx.blocks[b].not_guards bts= ins.params[0];
			]
			b := bb;
		]
	]

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		for ili := 0 to len(ctx.blocks[bgi].instrs) do [
			var igi := ctx.blocks[bgi].instrs[ili];
			var ins := ctx.instrs[igi];
			if ins.opcode = P_Return then [
				ctx.return_ins := ins;
			]
		]
		for i := 0 to len(ctx.blocks[bgi].post_list) do [
			var p := ctx.blocks[bgi].post_list[i];
			// TODO: this doesn't eliminate all loops
			if ctx.blocks[p].dominates bt bgi then [
				ctx.blocks[bgi].post_cut_nodes bts= i;
				ctx.blocks[p].pre_cut_nodes := true;
			]
		]
		var str : bytes;
		ctx, str := get_z3_bb_name(ctx, bgi);
		z3_eval_noret(ctx, "(declare-const " + str + " Bool)");
	]

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		for ili := 0 to len(ctx.blocks[bgi].instrs) do [
			var igi := ctx.blocks[bgi].instrs[ili];
			var ins := ctx.instrs[igi];
			if ins.opcode = P_Invariant then [
				if not len_greater_than(ctx.blocks[bgi].pred_list, 0) then [
					var str := "A block with invariant statement has not predecessor in " + ctx.name;
					return exception_make_str(unit_type, ec_async, error_compiler_error, 0, false, str);

				]
				for i := 0 to len(ctx.blocks[bgi].pred_list) do [
					var var1 : bytes;
					ctx, var1 := allocate_variable(ctx, ins.params[0], i + 1);
					if len(var1) = 0 then
						var1 := "false";
					var new_blk := ctx.blocks[bgi].pred_list[i];
					ctx.blocks[new_blk].added_claims +<= var1;
				]
			]
		]
	]

	for bgi := 0 to len(ctx.blocks) do [
		if not ctx.blocks[bgi].active then
			continue;
		var assumes := "";
		var claims := "";
		var guards := "";
		var all_phis := "";
		for i := 0 to len(ctx.blocks[bgi].pred_list) do [
			var p := ctx.blocks[bgi].pred_list[i];
			var guard : bytes;
			if len_greater_than(ctx.blocks[p].instrs, 0) then [
				var ins := ctx.instrs[ctx.blocks[p].instrs[len(ctx.blocks[p].instrs) - 1]];
				if ins.opcode = P_Jmp_False then [
					var pos := ctx.blocks[bgi].pred_position[i];
					var var1 : bytes;
					ctx, var1 := allocate_variable(ctx, ins.params[0], 0);
					if pos = 0 then
						guard := var1;
					else if pos = 1 then
						guard := "(not " + var1 + ")";
					else
						guard := "false";
				] else [
					guard := "true";
				]
			] else [
				guard := "true";
			]
			guards += " " + guard;
			if not ctx.blocks[bgi].pre_cut_nodes then [
				var phis := "";
				for ili := 0 to len(ctx.blocks[bgi].instrs) do [
					var igi := ctx.blocks[bgi].instrs[ili];
					var ins := ctx.instrs[igi];
					if ins.opcode <> P_Phi then
						break;
					var phi1 var1 : bytes;
					ctx, phi1 := allocate_variable(ctx, ins.params[0], 0);
					ctx, var1 := allocate_variable(ctx, ins.params[i + 1], 0);
					phis += " (= " + phi1 + " " + var1 + ")";
				]
				if len_greater_than(phis, 0) then [
					var gl := ctx.blocks[p].guards;
					while gl <> 0 do [
						var g : int := bsr gl;
						gl btr= g;
						var varg : bytes;
						ctx, varg := allocate_variable(ctx, g, 0);
						phis += " " + varg;
					]
					gl := ctx.blocks[p].not_guards;
					while gl <> 0 do [
						var g : int := bsr gl;
						gl btr= g;
						var varg : bytes;
						ctx, varg := allocate_variable(ctx, g, 0);
						phis += " (not " + varg + ")";
					]
					all_phis += " (and" + phis + ")";
				]
			]
		]
		if len_greater_than(all_phis, 0) then
			assumes += " (or" + all_phis + ")";
		if len_greater_than(guards, 0) then
			assumes += " (or" + guards + ")";
		for ili := 0 to len(ctx.blocks[bgi].instrs) do [
			var igi := ctx.blocks[bgi].instrs[ili];
			var ins := ctx.instrs[igi];
			if ins.opcode = P_Assume or ins.opcode = P_Invariant then [
				var var1 : bytes;
				ctx, var1 := allocate_variable(ctx, ins.params[0], 0);
				if len_greater_than(var1, 0) then
					assumes += " " + var1;
			] else if ins.opcode = P_Claim then [
				var var1 : bytes;
				ctx, var1 := allocate_variable(ctx, ins.params[0], 0);
				if len_greater_than(var1, 0) then [
					claims += " " + var1;
				]
			]
		]
		for i := 0 to len(ctx.blocks[bgi].added_claims) do [
			claims += " " + ctx.blocks[bgi].added_claims[i];
		]
		for i := 0 to len(ctx.blocks[bgi].post_list) do [
			if ctx.blocks[bgi].post_cut_nodes bt i then
				continue;
			var p := ctx.blocks[bgi].post_list[i];
			claims += " " + ctx.blocks[p].block_name;
		]
		if len(assumes) = 0 then
			assumes := " true";
		if len(claims) = 0 then
			claims := " true";
		z3_eval_noret(ctx, "(assert (= " + ctx.blocks[bgi].block_name + " (=> (and" + assumes + ") (and" + claims + "))))");
	]

	z3_eval_noret(ctx, "(assert (not " + ctx.blocks[0].block_name + "))");
	var b := z3_eval(ctx, "(check-sat)");
	if ctx.dump_z3 then
		eval debug("end verify function " + ctx.name);
	if list_begins_with(b, "unsat") then
		return unit_value;
	if list_begins_with(b, "sat") then [
		b := z3_eval(ctx, "(get-model)");
		b := "Verification of function " + ctx.name + " failed:" + nl + b;
		return exception_make_str(unit_type, ec_async, error_compiler_error, 0, false, b);
	]
	b := "Verification of function " + ctx.name + " inconclusive";
	return exception_make_str(unit_type, ec_async, error_compiler_error, 0, false, b);
]
