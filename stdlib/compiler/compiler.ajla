{*
 * Copyright (C) 2024, 2025 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.compiler;

uses compiler.common.evaluate;
uses compiler.parser.dict;
uses compiler.optimize.defs;

fn optimize_function(path_idx : int, file : bytes, program : bool, fn_idx : list(int)) : list(pcode_t);
fn get_unoptimized_function(path_idx : int, file : bytes, program : bool, fn_idx : list(int)) : list(pcode_t);
fn optimize_specialized_function(path_idx : int, file : bytes, program : bool, fn_idx : list(int), spec_data : list(pcode_t)) : list(pcode_t);
fn compile_module(lp : bytes, path_idx : int, file : bytes, program : bool) : (list(list(pcode_t)), list(module_unique_id));

implementation

uses io;
uses compiler.parser.unit;
uses compiler.optimize.utils;
uses compiler.optimize.ssa;
uses compiler.optimize.spec;

fn compile_module(lp : bytes, path_idx : int, file : bytes, program : bool) : (list(list(pcode_t)), list(module_unique_id))
[
	var w := unsafe_get_world;

	var d := list_break(lp, 0);
	d := d[ .. path_idx + 1];
	return compile_module_2(w, d, file, program);
]

fn get_inline(f : function, optimized : bool) : list(pcode_t)
[
	//return optimize_function(f.path_idx, f.un, f.program, f.fn_idx);
	var pc := empty(pcode_t);
	pc +<= len(f.fn_idx);
	for i := 0 to len(f.fn_idx) do
		pc +<= f.fn_idx[i];
	pc +<= len(f.spec_data);
	for i := 0 to len(f.spec_data) do
		pc +<= f.spec_data[i];
	return load_optimized_pcode(f.path_idx, f.un, f.program, pc, optimized);
]

fn optimize_function_saved~save(lp : bytes, path_idx : int, file : bytes, program : bool, fn_idx : list(int), verify_pattern : bytes) : list(pcode_t)
[
	var pcod, modules := compile_module~save(lp, path_idx, file, program);
	var pc := pcod[fn_idx[0]];
	pc := function_extract_nested(pc, fn_idx);
	var func := process_pcode(pc, get_inline, verify_pattern);
	return func;
]

fn optimize_function(path_idx : int, file : bytes, program : bool, fn_idx : list(int)) : list(pcode_t)
[
	var verify_pattern := get_dump("verify");
	return optimize_function_saved(libpath, path_idx, file, program, fn_idx, verify_pattern);
]

fn get_unoptimized_function(path_idx : int, file : bytes, program : bool, fn_idx : list(int)) : list(pcode_t)
[
	var pcod, modules := compile_module~save(libpath, path_idx, file, program);
	var pc := pcod[fn_idx[0]];
	pc := function_extract_nested(pc, fn_idx);
	return pc;
]

fn optimize_specialized_function_saved~save(path_idx : int, file : bytes, program : bool, fn_idx : list(int), spec_data : list(pcode_t), verify_pattern : bytes) : list(pcode_t)
[
	var pc : list(pcode_t);
	if path_idx > 0 then [
		pc := get_unoptimized_function(path_idx, file, program, fn_idx);
	] else [
		pc := empty(pcode_t);
		pc +<= len(fn_idx);
		for i := 0 to len(fn_idx) do
			pc +<= fn_idx[i];
		pc +<= 0;
		pc := load_optimized_pcode(path_idx, file, program, pc, false);
	]
	var func := spec_pcode(pc, spec_data, get_inline, verify_pattern);
	return func;
]

fn optimize_specialized_function(path_idx : int, file : bytes, program : bool, fn_idx : list(int), spec_data : list(pcode_t)) : list(pcode_t)
[
	var verify_pattern := get_dump("verify");
	var func := optimize_specialized_function_saved(path_idx, file, program, fn_idx, spec_data, verify_pattern);
	return func;
]
