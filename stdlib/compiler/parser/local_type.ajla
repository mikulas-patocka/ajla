{*
 * Copyright (C) 2024 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.parser.local_type;

uses compiler.parser.dict;
uses compiler.parser.type;

fn get_record_type_cc(ctx : function_context, cc : compare_context) : (function_context, int);
fn get_array_type_cc(ctx : function_context, cc : compare_context, typ : int) : int;
fn generate_local_types(ctx : function_context) : function_context;

implementation

uses compiler.common.gvn;
uses compiler.parser.gen2;

fn local_type_idx(ctx : function_context, lt : local_type) : (function_context, int)
[
	var idx := len(ctx.local_types);
	ctx.local_types +<= lt;
	return ctx, idx;
]

fn get_record_local_type(ctx rec_ctx : function_context) : (function_context, int)
[
	var lt := local_type.[
		mode : Local_Type_Record,
		args : generate_function_id(rec_ctx.id) + list(pcode_t).[ 0 ],
	];
	return local_type_idx(ctx, lt);
]

fn get_record_type_cc(ctx : function_context, cc : compare_context) : (function_context, int)
[
	var rec := cc.ctx.record_def.j;
	if not rec.is_option then [
		return get_record_local_type(ctx, cc.ctx);
	] else [
		if rec.is_flat_option, rec.always_flat_option then [
			return ctx, T_AlwaysFlatOption;
		] else if rec.is_flat_option then [
			return ctx, T_FlatOption;
		] else [
			return ctx, T_Undetermined;
		]
	]
]

fn get_array_type_cc(ctx : function_context, cc : compare_context, typ : int) : int
[
	var content_cc, content_typ := get_base_definition(ctx, cc, typ, false);
	if typ < 0 and typ <> T_UnknownType then
		return typ;
	return T_Undetermined;
]

fn get_local_type(ctx : function_context, i : int) : (function_context, int)
[
	var cc, typ := get_deep_type_of_var(ctx, i);
	if typ = T_Record then [
		return get_record_type_cc(ctx, cc);
	]
	return ctx, get_array_type_cc(ctx, cc, typ);
]

fn generate_local_types(ctx : function_context) : function_context
[
	for i := 0 to len(ctx.variables) do [
		var lt : int;
		ctx, lt := get_local_type(ctx, i);
		ctx.variables[i].local_type := lt;
	]
	return ctx;
]
