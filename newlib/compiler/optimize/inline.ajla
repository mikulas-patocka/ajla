{*
 * Copyright (C) 2024, 2025 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.optimize.inline;

uses compiler.optimize.defs;

fn do_inline_or_specialize(ctx new_ctx : context, bgi : int, ili ili_n : int, call_params call_result : list(pcode_t)) : context;
fn inline_functions(ctx : context) : context;

implementation

uses compiler.optimize.utils;

const inline_unoptimized_limit := 128;
const inline_optimized_limit := 512;

fn do_inline(ctx : context, bgi : int, ili : int, call_mode : pcode_t, autoinline : bool) : (context, bool)
[
	var block := ctx.blocks[bgi];
	var igi := block.instrs[ili];
	var ins := ctx.instrs[igi];
	var l, f := function_load(ins.params[3 .. ]);
	l := 3 + l;
	var call_params := ins.params[l .. l + ins.params[2] * 2];
	var call_result := ins.params[	   l + ins.params[2] * 2 ..
					   l + ins.params[2] * 2 + ins.params[1]];

	var new_pc := ctx.get_inline~save(f, true);

	var ft := new_pc[0] and Fn_Mask;

	if ft <> Fn_Function and ft <> Fn_Record and ft <> Fn_Option then
		abort internal("unsupported function type " + ntos(new_pc[0]));

	if ft <> Fn_Function and call_mode <> Call_Mode_Flat then
		return ctx, false;

	if ft = Fn_Option then
		return ctx, false;

	if autoinline, len_greater_than(new_pc, inline_optimized_limit) then
		return ctx, false;

	var new_ctx := load_function_context(new_pc, ctx.get_inline);

	ctx := do_inline_or_specialize(ctx, new_ctx, bgi, ili, 1, call_params, call_result);

	return ctx, true;
]

fn do_inline_or_specialize(ctx new_ctx : context, bgi : int, ili ili_n : int, call_params call_result : list(pcode_t)) : context
[
	var block := ctx.blocks[bgi];

	var tail_block := new_basic_block;
	var tail_block_bgi := len(ctx.blocks);
	tail_block.post_list := block.post_list;
	for i := 0 to len(tail_block.post_list) do [
		var post_bgi := tail_block.post_list[i];
		var post_block := ctx.blocks[post_bgi];
		for j := 0 to len(post_block.pred_list) do [
			if post_block.pred_list[j] = bgi then
				ctx.blocks[post_bgi].pred_list[j] := tail_block_bgi;
		]
	]
	tail_block.instrs := block.instrs[ ili + ili_n .. ];
	for i := 0 to len(tail_block.instrs) do [
		var vgi := tail_block.instrs[i];
		ctx.instrs[vgi].bb := tail_block_bgi;
	]
	ctx.blocks +<= tail_block;
	ctx.blocks[bgi].instrs := ctx.blocks[bgi].instrs[ .. ili ];
	ctx.blocks[bgi].post_list := list(int).[ len(ctx.blocks) ];

	for i := 0 to len(new_ctx.local_types) do [
		var lt := new_ctx.local_types[i];
		if lt is rec then [
			for i := 0 to len(lt.rec.types) do [
				if lt.rec.types[i] >= 0 then
					lt.rec.types[i] += len(ctx.local_types);
			]
		] else if lt is arr then [
			if lt.arr >= 0 then
				lt.arr += len(ctx.local_types);
		] else if lt is flat_rec then [
			lt.flat_rec.non_flat_record += len(ctx.local_types);
			for j := 0 to len(lt.flat_rec.flat_types) do [
				if lt.flat_rec.flat_types[j] >= 0 then
					lt.flat_rec.flat_types[j] += len(ctx.local_types);
			]
		] else if lt is flat_array then [
			lt.flat_array.non_flat_array += len(ctx.local_types);
			if lt.flat_array.flat_entry_type >= 0 then
				lt.flat_array.flat_entry_type += len(ctx.local_types);
		]
		new_ctx.local_types[i] := lt;
	]

	for i := 0 to len(new_ctx.instrs) do [
		if new_ctx.instrs[i].opcode = P_BinaryOp then
			new_ctx.instrs[i].params[2] and= not Flag_Fused_Bin_Jmp;
		if new_ctx.instrs[i].opcode = P_BinaryConstOp then
			new_ctx.instrs[i].params[2] and= not Flag_Fused_Bin_Jmp;
		var s := new_ctx.instrs[i].read_set or new_ctx.instrs[i].write_set;
		while s <> 0 do [
			var p : int := bsr s;
			s btr= p;
			new_ctx.instrs[i].params[p] += len(ctx.variables);
		]
		new_ctx.instrs[i].bb += len(ctx.blocks);
	]

	for i := 0 to len(new_ctx.variables) do [
		if new_ctx.variables[i].type_index >= 0 then
			new_ctx.variables[i].type_index += len(ctx.variables);
		if new_ctx.variables[i].runtime_type >= 0 then
			new_ctx.variables[i].runtime_type += len(ctx.local_types);
	]

	for i := 0 to len(new_ctx.blocks) do [
		var new_block := new_ctx.blocks[i];
		if not new_block.active then
			continue;

		if i = 0 then [
			var first_instr_igi := new_block.instrs[0];
			var first_instr := new_ctx.instrs[first_instr_igi];
			if first_instr.opcode <> P_Args then
				abort internal("the first instruction is not Args");
			new_ctx.blocks[i].instrs := new_ctx.blocks[i].instrs[1 .. ];
			if len(first_instr.params) * 2 <> len(call_params) then
				abort internal("call mismatch when inlining " + new_ctx.name + " into " + ctx.name);
			for j := 0 to len(first_instr.params) do [
				var cp := call_params[j * 2 + 1];
				var arg := first_instr.params[j];
				//eval debug("args types " + ntos(j) + ": " + ntos(cp_rt) + " " + ntos(arg_rt));

				var copy_in := create_instr(P_Copy, list(pcode_t).[ arg, 0, cp ], bgi);
				var copy_igi := len(ctx.instrs);
				ctx.blocks[bgi].instrs +<= copy_igi;
				ctx.instrs +<= copy_in;
			]
			new_ctx.blocks[i].pred_list := list(int).[ bgi ];
			new_ctx.blocks[i].pred_position := list(int).[ 0 ];
		] else [
			for j := 0 to len(new_block.pred_list) do
				new_ctx.blocks[i].pred_list[j] += len(ctx.blocks);
		]

		new_block := new_ctx.blocks[i];

		if len_greater_than(int, new_block.instrs, 0) then [
			var last_instr_igi := new_block.instrs[len(new_block.instrs) - 1];
			var last_instr := new_ctx.instrs[last_instr_igi];
			if last_instr.opcode = P_Return then [
				new_ctx.blocks[i].instrs := new_ctx.blocks[i].instrs[ .. len(new_block.instrs) - 1];
				for j := 0 to len(last_instr.params) shr 1 do [
					var rp := last_instr.params[j * 2 + 1];
					var cr := call_result[j];
					//eval debug("ret types " + ntos(j) + ": " + ntos(rp_rt) + " " + ntos(cr_rt));

					var copy_in := create_instr(P_Copy, list(pcode_t).[ call_result[j], 0, rp ], len(ctx.blocks) + i);
					var copy_igi := len(new_ctx.instrs);
					new_ctx.blocks[i].instrs +<= copy_igi;
					new_ctx.instrs +<= copy_in;
				]
				new_ctx.blocks[i].post_list := list(int).[ tail_block_bgi ];
				ctx.blocks[tail_block_bgi].pred_list +<= len(ctx.blocks) + i;
				ctx.blocks[tail_block_bgi].pred_position +<= 0;
				goto done_post_list;
			]
		]

		for j := 0 to len(new_ctx.blocks[i].post_list) do
			new_ctx.blocks[i].post_list[j] += len(ctx.blocks);
done_post_list:

		var instrs := empty(int);
		for j := 0 to len(new_ctx.blocks[i].instrs) do [
			var ins := new_ctx.instrs[new_ctx.blocks[i].instrs[j]];
			if ins.opcode = P_Line_Info then
				continue;
			if ins.opcode = P_Claim or ins.opcode = P_Assume, len(ins.params) > 1 then
				continue;
			instrs +<= new_ctx.blocks[i].instrs[j];
		]
		new_ctx.blocks[i].instrs := instrs;

		for j := 0 to len(new_ctx.blocks[i].instrs) do
			new_ctx.blocks[i].instrs[j] += len(ctx.instrs);
	]

	ctx.local_types += new_ctx.local_types;
	ctx.instrs += new_ctx.instrs;
	ctx.blocks += new_ctx.blocks;
	ctx.variables += new_ctx.variables;

	//eval dump_graph(ctx);

	return ctx;
]

fn inline_functions(ctx : context) : context
[
again:
	var did_something := false;
	for bgi := 0 to len(ctx.blocks) do [
		var block := ctx.blocks[bgi];
		if not block.active then
			continue;
		var l := len(block.instrs);
		for ili := 0 to l do [
			var igi := ctx.blocks[bgi].instrs[ili];
			var ins := ctx.instrs[igi];
			if ins.opcode = P_Call then [
				//xeval debug("considering inline of " + ctx.name + " -> " + function_name(ins.params[3 .. ]) + ": " + ntos(ins.params[0]));
				var call_mode := ins.params[0];
				var autoinline := false;
				if call_mode = Call_Mode_Inline or call_mode = Call_Mode_Flat then [
do_inline:
					var progress : bool;
					ctx, progress := do_inline(ctx, bgi, ili, call_mode, autoinline);
					if progress then [
						did_something := true;
						ctx.should_retry := true;
						break;
					]
				] else if call_mode = Call_Mode_Unspecified, sysprop(SystemProperty_NoInline) = 0 then [
					var pc := function_pcode(ins.params[3 .. ], ctx.get_inline);
					if pc[0] bt bsf Fn_AutoInline, not len_greater_than(pc, inline_unoptimized_limit) then [
						//xeval debug("auto-inlining " + ctx.name + " -> " + function_name(ins.params[3 .. ], ctx.get_inline) + ", " + ntos(len(pc)));
						autoinline := true;
						goto do_inline;
					]
					//xeval function_name(ins.params[3 .. ]);
				]
			]
		]
	]
	if did_something then
		goto again;

	return ctx;
]
