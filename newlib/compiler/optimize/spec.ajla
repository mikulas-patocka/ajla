{*
 * Copyright (C) 2025 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.optimize.spec;

uses compiler.optimize.defs;

type spec_context;

fn new_spec_context(n : int) : spec_context;
fn spec_add_variable(spec_ctx : spec_context, ctx : context, a v : int) : spec_context;
fn spec_extract_pcode(spec_ctx : spec_context) : list(pcode_t);
fn spec_pcode(pc : list(pcode_t), spec_data : list(pcode_t), get_inline : fn(function, bool) : list(pcode_t), verify_pattern : bytes) : list(pcode_t);

implementation

uses exception;
uses compiler.common.blob;
uses compiler.optimize.utils;

record spec_variable [
	runtime_type : int;
	type_idx : int;
]

record spec_context [
	arguments : int;
	local_types : list(local_type);
	variables : list(spec_variable);
	instrs : list(instruction);
	outputs : list(int);
]

fn new_spec_context(n : int) : spec_context
[
	var spec_ctx := spec_context.[
		arguments : 0,
		local_types : empty(local_type),
		variables : empty(spec_variable),
		instrs : empty(instruction),
		outputs : empty(int),
	];
	return spec_ctx;
]

fn add_local_type(spec_ctx : spec_context, ctx : context, runtime_type : int) : (spec_context, int)
[
	if runtime_type < 0 then
		return spec_ctx, runtime_type;
	var lt := ctx.local_types[runtime_type];
	if lt is rec then [
		for i := 0 to len(lt.rec.types) do
			spec_ctx, lt.rec.types[i] := add_local_type(spec_ctx, ctx, lt.rec.types[i]);
	] else if lt is arr then [
		spec_ctx, lt.arr := add_local_type(spec_ctx, ctx, lt.arr);
	] else if lt is flat_rec then [
		spec_ctx, lt.flat_rec.non_flat_record := add_local_type(spec_ctx, ctx, lt.flat_rec.non_flat_record);
		for i := 0 to len(lt.flat_rec.flat_types) do
			spec_ctx, lt.flat_rec.flat_types[i] := add_local_type(spec_ctx, ctx, lt.flat_rec.flat_types[i]);
	] else if lt is flat_array then [
		spec_ctx, lt.flat_array.non_flat_array := add_local_type(spec_ctx, ctx, lt.flat_array.non_flat_array);
		spec_ctx, lt.flat_array.flat_entry_type := add_local_type(spec_ctx, ctx, lt.flat_array.flat_entry_type);
	]
	var r := len(spec_ctx.local_types);
	spec_ctx.local_types +<= lt;
	return spec_ctx, r;
]

fn spec_add_variable_recursive(spec_ctx : spec_context, ctx : context, v : int) : (spec_context, int);

fn add_variable(spec_ctx : spec_context, ctx : context, w : int) : spec_context
[
	var runtime_type type_idx : int;
	spec_ctx, runtime_type := add_local_type(spec_ctx, ctx, ctx.variables[w].runtime_type);
	spec_ctx, type_idx := spec_add_variable_recursive(spec_ctx, ctx, ctx.variables[w].type_index);
	var nv := spec_variable.[
		runtime_type : runtime_type,
		type_idx : type_idx,
	];
	spec_ctx.variables +<= nv;
	return spec_ctx;
]

fn spec_add_variable_recursive(spec_ctx : spec_context, ctx : context, v : int) : (spec_context, int)
[
	if v < 0 then
		return spec_ctx, v;
	var igi := ctx.variables[v].defining_instr;
	var ins := ctx.instrs[igi];
	var opcode := ins.opcode;
	var allowed_opcodes : int64 := 0
		bts P_BinaryOp
		bts P_BinaryConstOp
		bts P_UnaryOp
		bts P_Copy
		bts P_Copy_Type_Cast
		bts P_Fn
		bts P_Load_Fn
		bts P_Curry
		bts P_Call
		bts P_Call_Indirect
		bts P_Load_Const
		bts P_Structured_Write
		bts P_Record_Create
		bts P_Record_Load
		bts P_Option_Create
		bts P_Option_Load
		bts P_Option_Test
		bts P_Option_Ord
		bts P_Array_Flexible
		bts P_Array_Fixed
		bts P_Array_Create
		bts P_Array_Fill
		bts P_Array_String
		bts P_Array_Unicode
		bts P_Array_Load
		bts P_Array_Len
		bts P_Array_Len_Greater_Than
		bts P_Array_Sub
		bts P_Array_Skip
		bts P_Array_Append
		bts P_Array_Append_One
		bts P_Array_Flatten
		;
	if not allowed_opcodes bt opcode then
		abort exception_make(int, ec_sync, error_user, 0, false);
	var rs := ins.read_set;
	while rs <> 0 do [
		var ridx : int := bsf rs;
		rs btr= ridx;
		var r := ins.params[ridx];
		var nr : int;
		spec_ctx, nr := spec_add_variable_recursive(spec_ctx, ctx, r);
		ins.params[ridx] := nr;
	]
	var ws := ins.write_set;
	var result := -1;
	while ws <> 0 do [
		var widx : int := bsf ws;
		ws btr= widx;
		var w := ins.params[widx];
		var nw := len(spec_ctx.variables);
		if v = w then
			result := nw;
		ins.params[widx] := nw;
		spec_ctx := add_variable(spec_ctx, ctx, w);
	]
	if result = -1 then
		abort internal("output variable not found in write set");
	spec_ctx.instrs +<= ins;
	return spec_ctx, result;
]

fn spec_add_variable(spec_ctx : spec_context, ctx : context, a v : int) : spec_context
[
	var o : int;
	spec_ctx.arguments bts= a;
	spec_ctx, o := spec_add_variable_recursive(spec_ctx, ctx, v);
	spec_ctx.outputs +<= o;
	return spec_ctx;
]

fn spec_extract_pcode(spec_ctx : spec_context) : list(pcode_t)
[
	var real_returns := 0;
	for i := 0 to len(spec_ctx.outputs) do [
		var o := spec_ctx.outputs[i];
		if o >= 0,
		   spec_ctx.variables[o].type_idx <> T_Type then
			real_returns += 1;
	]
	var rpc := empty(pcode_t);
	rpc +<= popcnt spec_ctx.arguments;
	var args := spec_ctx.arguments;
	while args <> 0 do [
		var a := bsf args;
		args btr= a;
		rpc +<= a;
	]
	rpc += list(pcode_t).[
		Fn_Function,
		Call_Mode_Inline,
		0,
		len(spec_ctx.local_types),
		len(spec_ctx.variables),
		0,
		len(spec_ctx.outputs),
		real_returns,
		0,
	];
	rpc += blob_store("*spec*");
	for i := 0 to len(spec_ctx.local_types) do [
		rpc += dump_local_type(spec_ctx.local_types[i]);
	]
	for i := 0 to len(spec_ctx.variables) do [
		var v := spec_ctx.variables[i];
		rpc += list(pcode_t).[
			v.type_idx,
			v.runtime_type,
			-1,
			0,
		];
		rpc += blob_store("");
	]
	var i1 := instruction.[
		opcode : P_Args,
		params : empty(pcode_t),
	];
	var i2 := instruction.[
		opcode : P_Return_Vars,
		params : empty(pcode_t),
	];
	var i3 := instruction.[
		opcode : P_Return_Vars,
		params : empty(pcode_t),
	];
	for i := 0 to len(spec_ctx.outputs) do [
		i2.params +<= spec_ctx.outputs[i];
		i3.params +<= 0;
		i3.params +<= spec_ctx.outputs[i];
	]
	spec_ctx.instrs := [ i1, i2 ] + spec_ctx.instrs + [ i3 ];
	for i := 0 to len(spec_ctx.instrs) do [
		var instr := spec_ctx.instrs[i];
		rpc +<= instr.opcode;
		rpc +<= len(instr.params);
		rpc += instr.params;
	]
	return rpc;
]

fn spec_pcode(pc : list(pcode_t), spec_data : list(pcode_t), get_inline : fn(function, bool) : list(pcode_t), verify_pattern : bytes) : list(pcode_t)
[
	eval debug("spec_pcode");
	var n_args := spec_data[0];
	var args := 0;
	for i := 0 to n_args do
		args bts= spec_data[1 + i];
	var ptr := 1 + n_args;

	var new_ctx := load_function_context(spec_data[ptr .. ], get_inline);

	var ctx := load_function_context(pc, get_inline);

	pc[5] -= n_args;

	var i0 := ctx.blocks[0].instrs[0];
	var instr_args := ctx.instrs[i0];
	if instr_args.opcode <> P_Args then
		abort internal("The function doesn't start with P_Args");
	var instr_args_params := empty(pcode_t);
	for i := 0 to len(instr_args.params) do [
		if not args bt i then
			instr_args_params +<= instr_args.params[i];
	]
	ctx.instrs[i0].params := instr_args_params;

	xeval new_ctx;
	xeval ctx;

	eval debug("evaluated");

	abort;
]
