{*
 * Copyright (C) 2024, 2025 Mikulas Patocka
 *
 * This file is part of Ajla.
 *
 * Ajla is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Ajla is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Ajla. If not, see <https://www.gnu.org/licenses/>.
 *}

private unit compiler.parser.type;

uses compiler.parser.dict;

const predefined_byte := 0;
const predefined_bytes := 1;
const predefined_char := 2;
const predefined_string := 3;
const predefined_list := 4;
const predefined_xarray := 7;
const predefined_len := 8;

fn type_is_flat(t : int) := t <= T_SInt8 and t >= T_Bool;

record compare_fn_stack [
	cc : compare_context;
	main_def : int;
	dest_def : int;
	dest_types : list(int);
]

record inferred_result [
	arg : int;
	ctx : function_context;
	typ : int;
]

option teq [
	eq;
	noeq;
	dont_know;
	inferred : inferred_result;
]

fn get_type_of_var(ctx : function_context, v : int) : int;
fn convert_type(ctx : function_context, vd : variable_dictionary, a : int, cc : compare_context, typ : int, inferred_bias : int, do_convert : bool, t : tokens) : (function_context, int, teq);

fn new_compare_argument(cc : compare_context, idx : int) : compare_argument;
fn new_compare_context(ctx : function_context) : compare_context;
fn new_compare_context_from_function(ctx : function_context) : compare_context;
fn set_llt_main(cc : compare_context, val : int) : compare_context;
fn empty_compare_context : compare_context;

fn get_defined_maybe(cc : compare_context, typ : int) : maybe(instruction);
fn get_defined(cc : compare_context, typ : int) : instruction;

const gbd_const_flag := 62;
const gbd_const_type := 63;
const gbd_const_blob := 71;
fn typ_is_const(typ : int) : bool;
fn get_base_definition(ctx : function_context, cc : compare_context, typ : int, want_record : bool) : (compare_context, int);
fn get_deep_type_of_var(ctx : function_context, v : int) : (compare_context, int);
fn have_type_invariants(ctx : function_context, cc : compare_context, typ : int) : bool;
fn get_type_invariants(ctx : function_context, cc : compare_context, typ : int) : (compare_context, int, list(compare_argument));

fn verify_type_equality(ctx : function_context,
			cc1 : compare_context, typ1 : int, fn_stack1 : list(compare_fn_stack),
			cc2 : compare_context, typ2 : int, fn_stack2 : list(compare_fn_stack)) : teq;

fn evaluate_type(ctx : function_context, cc : compare_context, typ : int, fn_stack : list(compare_fn_stack), t : tokens) : (function_context, int);
fn evaluate_type_var(ctx : function_context, cc : compare_context, typ : int, fn_stack : list(compare_fn_stack), t : tokens) : (function_context, int);

fn array_shape(ctx : function_context, cc : compare_context, a : int, t : tokens) : (bool, compare_context, list(int));
fn list_type(ctx : function_context, cc : compare_context, a : int, err : bool, t : tokens) : (compare_context, int);
fn evaluate_list_type(ctx : function_context, a : int, t : tokens) : (function_context, int);
fn get_list_id : function_unique_id;

fn generate_assumes_or_claims(ctx : function_context, a : int, inv : list(compare_argument), cl : bool, t : tokens) : function_context;
fn generate_foreach_assumes_or_claims(ctx : function_context, a : int, inv : list(compare_argument), cl : bool, t : tokens) : function_context;

implementation

uses compiler.common.blob;
uses compiler.common.evaluate;
uses compiler.parser.gen;
uses compiler.parser.gen2;
uses compiler.parser.alloc;
uses compiler.parser.function;
uses exception;

fn get_type_of_var(ctx : function_context, v : int) : int
[
	if v <= T_InferredType then
		abort internal("get_type_of_var: getting type of inference marker");
	else if v = T_Type then
		return T_TypeOfType;
	else if v < 0 then
		return T_Type;
	else
		return ctx.variables[v].type_idx;
]

fn do_conversion(ctx : function_context, vd : variable_dictionary, a a_typ : int, cc : compare_context, typ : int, t : tokens) : (function_context, int)
[
	var my_cc := new_compare_context(ctx);
	var cc1, deep_a_typ := get_base_definition(ctx, my_cc, a_typ, true);
	var cc2, deep_typ := get_base_definition(ctx, cc, typ, true);
	if deep_a_typ = T_Integer, deep_typ <= T_SInt8, deep_typ >= T_Integer128 then [
		//eval debug("do_conversion 1: eligible for shortcut: " + ntos(a_typ) + ", " + ntos(deep_a_typ) + " - " + ntos(typ) + ", " + ntos(deep_typ));
		var l : int;
		ctx, l := alloc_local_variable(ctx, deep_typ, true, false);
		ctx := generate_UnaryOp(ctx, Un_ConvertFromInt, a, l);
		return ctx, l;
	]
	if deep_typ = T_Integer, deep_a_typ <= T_SInt8, deep_a_typ >= T_Integer128 then [
		//eval debug("do_conversion 2: eligible for shortcut: " + ntos(a_typ) + ", " + ntos(deep_a_typ) + " - " + ntos(typ) + ", " + ntos(deep_typ));
		var l : int;
		ctx, l := alloc_local_variable(ctx, deep_typ, true, false);
		ctx := generate_UnaryOp(ctx, Un_ConvertToInt, a, l);
		return ctx, l;
	]
	var conversions := get_implicits(ctx, true);
	for im := 0 to len(conversions) do [
		var ctx2 := ctx;

		var def := conversions[im];
		if def.signature.n_arguments < 1 or def.signature.n_return_values <> 1 then
			goto cont;

		var result : list(int);
		ctx, result := process_direct_function(ctx, vd, def, Call_Mode_Unspecified, list(int).[ a ], list(int).[ 0 ], cc, typ, false, t);

		if is_exception ctx, exception_type ctx = error_compiler_error then
			goto cont;

		var r_typ := get_type_of_var(ctx, result[0]);
		my_cc := new_compare_context(ctx);
		var match := verify_type_equality(ctx, cc, typ, empty(compare_fn_stack), my_cc, r_typ, empty(compare_fn_stack));

		if not match is eq then
			goto cont;

		return ctx, result[0];

cont:
		ctx := ctx2;
	]
	abort compiler_error("Types do not match", t);
]

fn convert_type(ctx : function_context, vd : variable_dictionary, a : int, cc : compare_context, typ : int, inferred_bias : int, do_convert : bool, t : tokens) : (function_context, int, teq)
[
	var my_cc := new_compare_context(ctx);
	var a_typ := get_type_of_var(ctx, a);
	var match := verify_type_equality(ctx, my_cc, a_typ, empty(compare_fn_stack), cc, typ, empty(compare_fn_stack));
	if match is inferred then
		return ctx, 0, match;
	if match is eq then
		return ctx, a, teq.dont_know;
	if not do_convert then
		abort compiler_error("Types do not match", t);

	var cc_from, typ_from, inv_from := get_type_invariants(ctx, my_cc, a_typ);
	var cc_to, typ_to, inv_to := get_type_invariants(ctx, cc, typ);

	match := verify_type_equality(ctx, cc_from, typ_from, empty(compare_fn_stack), cc_to, typ_to, empty(compare_fn_stack));
	if match is inferred then
		return ctx, 0, match;

	ctx := generate_assumes_or_claims(ctx, a, inv_from, false, t);

	var c : int;
	if match is eq then [
		c := a;
	] else [
		var list_cc_from, list_typ_from := list_type(ctx, cc_from, typ_from, false, t);
		var list_cc_to, list_typ_to := list_type(ctx, cc_to, typ_to, false, t);
		if list_typ_from <> T_InvalidType, list_typ_to <> T_InvalidType then [
			var ls_cc_from, ls_typ_from, ls_inv_from := get_type_invariants(ctx, list_cc_from, list_typ_from);
			var ls_cc_to, ls_typ_to, ls_inv_to := get_type_invariants(ctx, list_cc_to, list_typ_to);
			match := verify_type_equality(ctx, ls_cc_from, ls_typ_from, empty(compare_fn_stack), ls_cc_to, ls_typ_to, empty(compare_fn_stack));
			if match is inferred then
				return ctx, 0, match;
			if not match is eq then
				goto try_explicit_conversion;
			ctx := generate_foreach_assumes_or_claims(ctx, a, ls_inv_from, false, t);
			c := a;
			ctx := generate_foreach_assumes_or_claims(ctx, c, ls_inv_to, true, t);
		] else [
try_explicit_conversion:
			ctx.inferred_base -= inferred_bias;
			ctx, c := do_conversion(ctx, vd, a, a_typ, cc_to, typ_to, t);
			ctx.inferred_base += inferred_bias;
		]
	]

	ctx := generate_assumes_or_claims(ctx, c, inv_to, true, t);

	return ctx, c, teq.dont_know;
]

fn new_compare_argument(cc : compare_context, idx : int) : compare_argument
[
	return compare_argument.[ cc : cc, idx : idx ];
]

fn new_compare_context(ctx : function_context) : compare_context
[
	var cc := compare_context.[
		ctx : ctx,
		root : true,
		args : empty(compare_argument),
		llt_main : maybe(int).n,
		llt_redirect : empty(compare_argument),
		return_redirect : empty(compare_argument),
		lambda_redirect : exception_make(list(int), ec_sync, error_record_field_not_initialized, 0, false),
		no_pattern_match : false,
		option_map : infinite(-1),
	];
	return cc;
]

fn new_compare_context_from_function(ctx : function_context) : compare_context
[
	var cc := new_compare_context(ctx);
	cc.root := false;
	return cc;
]

fn set_llt_main(cc : compare_context, val : int) : compare_context
[
	if cc.llt_main is j then
		abort internal("set_llt_main: llt_main already set");
	if len_greater_than(cc.llt_redirect, 0) then
		abort internal("set_llt_main: llt_redirect is not empty");
	cc.llt_main := maybe(int).j.(val);
	return cc;
]

fn empty_compare_context : compare_context
[
	return exception_make(compare_context, ec_sync, error_record_field_not_initialized, 0, false);
]


fn typ_is_const(typ : int) : bool := typ < 0 or typ >= 0 bts gbd_const_flag;


fn get_defined_maybe(cc : compare_context, typ : int) : maybe(instruction)
[
	if typ_is_const(typ) then
		return maybe(instruction).n;
	var va := cc.ctx.variables[typ];
	var def_at := va.defined_at;
	if def_at = defined_multiple then
		return maybe(instruction).n;
	if va.mut then
		return maybe(instruction).n;
	return maybe(instruction).j.(cc.ctx.instructions[def_at]);
]

fn get_defined(cc : compare_context, typ : int) : instruction
[
	var instr := get_defined_maybe(cc, typ);
	if instr is n then
		abort internal("get_defined: no defining instruction for " + ntos(typ));
	return instr.j;
]

fn is_non_const(ctx : function_context, cc : compare_context, typ : int) : bool
[
	if ctx.allow_vars then
		return false;
	if typ < 0 then
		return false;
	var va := cc.ctx.variables[typ];
	var def_at := va.defined_at;
	return va.defined_at = defined_multiple or va.mut;
]

fn cc_equal(cc1 cc2 : compare_context) : bool
[
	if cc1.ctx.id <> cc2.ctx.id then
		return false;
	if cc1.root <> cc2.root then
		return false;
	if len(cc1.args) <> len(cc2.args) then
		return false;
	for i := 0 to len(cc1.args) do [
		if cc1.args[i].idx <> cc2.args[i].idx then
			return false;
		if not cc_equal(cc1.args[i].cc, cc2.args[i].cc) then
			return false;
	]
	return true;
]

fn find_fn_stack_depth(fn_stack : list(compare_fn_stack), cc : compare_context, main_def : int) : (compare_fn_stack, int)
[
	for i := 0 to len(fn_stack) do [
		if cc_equal(fn_stack[i].cc, cc) and fn_stack[i].main_def = main_def then
			return fn_stack[i], len(fn_stack) - 1 - i;
	]
	return exception_make(compare_fn_stack, ec_sync, error_record_field_not_initialized, 0, false), -1;
]

fn decode_call(ctx : function_context, cc : compare_context, typ : int, instr : instruction) : (bool, function_unique_id, list(compare_argument), int)
[
	if instr.opcode = P_Call then [
		var args := empty(compare_argument);
		for i := 0 to pcode_Call_get_n_args(instr) do [
			args +<= new_compare_argument(cc, pcode_Call_get_arg(instr, i));
		]
		var fid := pcode_Call_get_unique_id(instr);
		var ret_idx := pcode_Call_find_return_index(instr, typ);
		return true, fid, args, ret_idx;
	]
	if instr.opcode = P_Call_Indirect then [
		var reverse_args := empty(compare_argument);
		if pcode_Call_Indirect_get_n_args(instr) <> 0 then
			abort internal("Call_Indirect with arguments");

		var fnn := pcode_Call_Indirect_get_fn_variable(instr);
		var fnn_cc := cc;
next_fn:
		var f_typ : int;
		var inv : list(compare_argument);
		fnn_cc, f_typ := get_base_definition(ctx, fnn_cc, fnn, false);
		var f_instrm := get_defined_maybe(fnn_cc, f_typ);
		if f_instrm is n then
			goto fail;
		var f_instr := f_instrm.j;

		if f_instr.opcode = P_Curry then [
			var i := pcode_Curry_get_n_curried_args(f_instr) - 1;
			while i >= 0 do [
				var ca := new_compare_argument(fnn_cc, pcode_Curry_get_arg(f_instr, i));
				reverse_args +<= ca;
				i -= 1;
			]
			fnn := pcode_Curry_get_fn_variable(f_instr);
			goto next_fn;
		]

		if f_instr.opcode <> P_Load_Fn then
			goto fail;
		if pcode_Load_Fn_get_n_curried_args(f_instr) <> 0 then
			abort internal("Load_Fn with arguments");
		var fid := pcode_Load_Fn_get_unique_id(f_instr);
		var ret_idx := pcode_Call_Indirect_find_return_index(instr, typ);
		return true, fid, list_reverse(reverse_args), ret_idx;
	]

fail:
	return false, exception_make(function_unique_id, ec_sync, error_record_field_not_initialized, 0, false), empty(compare_argument), -1;
]


fn encode_constant(t : int, cnst : list(pcode_t)) : int
[
	var c := 0 bts gbd_const_flag;
	c or= -t shl gbd_const_type;
	for i := 0 to len(cnst) do [
		var val : int := cnst[i];
		if val < 0 then
			val += #80000000;
		c or= val shl gbd_const_blob + (i shl 5);
	]
	return c;
]

fn decode_constant(c : int) : (int, list(pcode_t))
[
	var t := -(c shr gbd_const_type and (1 shl gbd_const_blob - gbd_const_type) - 1);
	c shr= gbd_const_blob;
	var l := empty(pcode_t);
	while true do [
		var up := c and #ffffffff;
		var p : pcode_t;
		if up < #80000000 then
			p := up;
		else
			p := up - #100000000;
		l +<= p;
		if len(l) >= blob_length(l) then
			break;
		c shr= 32;
	]
	return t, l;
]


record match_state [
	cc : compare_context;
	idx : int;
]

fn get_record_or_option(ctx : function_context, cc : compare_context, typ : int, want_option : bool) : record_definition
[
	var rec_cc, rec_typ := get_base_definition(ctx, cc, cc.ctx.variables[typ].type_idx, true);
	if rec_typ <> T_Record then
		abort internal("No record or option definition");
	var def := rec_cc.ctx.record_def.j;
	if def.is_option <> want_option then
		abort internal("Non-matching record definition");
	return def;
]

fn get_base_definition(ctx : function_context, cc : compare_context, typ : int, want_record : bool) : (compare_context, int)
[
restart_fail:
	var fail_cc := empty_compare_context;
	var fail_typ := T_UnknownType;

restart:
	if typ_is_const(typ) then
		return cc, typ;

	var cc_ctx := cc.ctx;

	if typ >= cc_ctx.n_arguments, typ < cc_ctx.n_arguments + cc_ctx.n_return_values then [
		var idx := typ - cc_ctx.n_arguments;
		if idx < len(cc.return_redirect) then
			return cc.return_redirect[idx].cc, cc.return_redirect[idx].idx;
	]

	if get_defined_maybe(cc, typ) is n then [
		if ctx.allow_vars then [
			if typ < len(cc.args) then [
				cc, typ := cc.args[typ].cc, cc.args[typ].idx;
				goto restart;
			]
			return cc, typ;
		]
		return fail_cc, fail_typ;
	]

	var def_at := cc_ctx.variables[typ].defined_at;

	fail_cc, fail_typ := cc, typ;

	if typ < len(cc.args) then [
		var option_map := cc.args[typ].cc.option_map[typ];
		cc, typ := cc.args[typ].cc, cc.args[typ].idx;
		if not typ_is_const(typ), option_map >= 0 then
			cc.option_map[typ] := option_map;
		goto restart;
	]

	if def_at = defined_argument then [
		return cc, typ;
	]

	var instr := cc_ctx.instructions[def_at];
	var opcode := instr.opcode;

	if opcode = P_Copy then [
		typ := pcode_Copy_get_source(instr);
		goto restart;
	]
	if opcode = P_Call or opcode = P_Call_Indirect then [
		var success, fid, args, ret_idx := decode_call(ctx, cc, typ, instr);
		if not success then
			return cc, typ;

		var f := search_function_from_id(ctx, fid);
		//eval debug("get_base_definition: " + i_decode(f.signature.name));
		//eval stacktrace(0 div 0);
		if f.signature.n_arguments <> len(args) then
			abort internal("P_Call: the number of arguments doesn't match");
		if f.body is n then
			return cc, typ;
		var body := f.body.j;

		var new_ctx := new_compare_context_from_function(body);
		new_ctx.args := args;

		if body.record_def is j then [
			if want_record then
				return new_ctx, T_Record;
			else
				return cc, typ;
		]

		if not body.is_pattern_matched then
			return cc, typ;

		if len(body.pattern_matching_info) = 1 then [
			cc, typ := new_ctx, body.pattern_matching_info[0].return_values[ret_idx];
			goto restart;
		]

		if cc.no_pattern_match then
			return cc, typ;

		new_ctx.no_pattern_match := true;
		var cnst_true := encode_constant(T_Bool, int_to_blob(1));
		var possible_patterns := 0;
		var states := fill(match_state.[ ], len(body.pattern_matching_info));
		var excluded_options := infinite(0);
		var excluded_all := false;
		var forced_options := empty(tuple2(int, int));
		for m := 0 to len(body.pattern_matching_info) do [
			if excluded_all then
				break;
			var pi := body.pattern_matching_info[m];
			var dont_know := false;
			var option_map := infinite(-1);
			var option_vars := empty(int);
			for i := 0 to len(forced_options) do [
				option_map[forced_options[i].v1] := forced_options[i].v2;
				option_vars +<= forced_options[i].v1;
			]
			for p := 0 to len(pi.conditions) do [
				var gbd_cc, gbd_idx := get_base_definition(ctx, new_ctx, pi.conditions[p], false);
				var match := verify_type_equality(ctx, new_ctx, pi.conditions[p], empty(compare_fn_stack), empty_compare_context, cnst_true, empty(compare_fn_stack));
				if match is noeq then
					goto skip_cond;
				else if match is dont_know then
					dont_know := true;
				else if not match is eq then
					return cc, typ;
				var da := get_defined_maybe(new_ctx, pi.conditions[p]);
				if da is j, da.j.opcode = P_Option_Test then [
					var option_var := pcode_Option_Test_get_option(da.j);
					var option_idx := pcode_Option_Test_get_index(da.j);
					if len(pi.conditions) = 1 then [
						var def := get_record_or_option(ctx, new_ctx, option_var, true);
						var excl := excluded_options[option_var];
						if excl bt option_idx then
							goto skip_cond;
						excl bts= option_idx;
						excluded_options[option_var] := excl;
						if popcnt excl = len(def.entries) then
							excluded_all := true;
						if (popcnt excl) + 1 = len(def.entries) then
							forced_options +<= mktuple2(option_var, bsf not excl);
					]
					if option_map[option_var] <> -1, option_map[option_var] <> option_idx then
						goto skip_cond;
					option_map[option_var] := option_idx;
					option_vars +<= option_var;
				]
			]
			states[m].cc, states[m].idx := get_base_definition(ctx, new_ctx, body.pattern_matching_info[m].return_values[ret_idx], false);
			for i := 0 to len(option_vars) do
				states[m].cc.option_map[option_vars[i]] := option_map[option_vars[i]];
			possible_patterns bts= m;
			if not dont_know then
				break;
skip_cond:
		]
		if possible_patterns = 0 then
			abort internal("No possible patterns");
		var p1 := bsf possible_patterns;
		possible_patterns btr= p1;
		while possible_patterns <> 0 do [
			var p2 := bsf possible_patterns;
			possible_patterns btr= p2;
			var match := verify_type_equality(ctx, states[p1].cc, states[p1].idx, empty(compare_fn_stack), states[p2].cc, states[p2].idx, empty(compare_fn_stack));
			if not match is eq then
				return cc, typ;
		]
		//new_ctx.option_map := states[p1].cc.option_map;
		new_ctx.no_pattern_match := false;
		cc, typ := new_ctx, body.pattern_matching_info[p1].return_values[ret_idx];
		goto restart;
	]
	if opcode = P_Load_Local_Type then [
		if cc.llt_main is j, pcode_Load_Local_Type_get_function(instr) = cc.llt_main.j then [
			if ctx.getting_dependencies >= 0 then
				return cc, typ;
			var r := cc.llt_redirect[pcode_Load_Local_Type_get_index(instr)];
			cc, typ := r.cc, r.idx;
			goto restart_fail;
		]
		return cc, typ;
	]
	if opcode = P_Record_Load then [
		var str_v := pcode_Record_Load_get_record(instr);
		var idx := pcode_Record_Load_get_index(instr);

		var def := get_record_or_option(ctx, cc, str_v, false);

		var rv_cc, rv_typ := get_base_definition(ctx, cc, str_v, false);
		var rv_instr := get_defined_maybe(rv_cc, rv_typ);
		if rv_instr is n then
			return cc, typ;
		if rv_instr.j.opcode <> P_Record_Create then
			return cc, typ;

		var rv_var := pcode_Record_Create_get_arg(rv_instr.j, idx);
		cc, typ := rv_cc, rv_var;

		goto restart;
	]
	if opcode = P_Load_Const then [
		var blob := pcode_Load_Const_get_blob(instr);
		var t := get_type_of_var(cc_ctx, typ);
		if not type_is_flat(t) then
			return cc, typ;
		return cc, encode_constant(t, blob);
	]
	fn get_constant(arg : int) : list(pcode_t)
	[
		var arg_cc, arg_typ := get_base_definition(ctx, cc, arg, false);
		if arg_typ < 0 or not arg_typ bt gbd_const_flag then
			return empty(pcode_t);
		var t, b := decode_constant(arg_typ);
		return b;
	]
	if opcode = P_BinaryOp then [
		var ccx, t := get_deep_type_of_var(cc_ctx, typ);
		var op := pcode_BinaryOp_get_op(instr);
		var arg1 := pcode_BinaryOp_get_arg1(instr);
		var arg2 := pcode_BinaryOp_get_arg2(instr);
		var ccx1, t1 := get_deep_type_of_var(cc_ctx, arg1);
		var inv : list(compare_argument);
		ccx1, t1, inv := get_type_invariants(ctx, ccx1, t1);
		if not type_is_flat(t) then
			abort internal("get_base_definition: invalid destination type for binary operation " + ntos(op) + ": " + ntos(t));
		if not type_is_flat(t1) then
			abort internal("get_base_definition: invalid source type for binary operation " + ntos(op) + ": " + ntos(t1));
		var arg1_blob := get_constant(arg1);
		var arg2_blob := get_constant(arg2);
		if t1 = T_Bool then [
			if op = Bin_And then [
				if len_greater_than(arg1_blob, 0) and blob_to_int(arg1_blob) = 0 or
				   len_greater_than(arg2_blob, 0) and blob_to_int(arg2_blob) = 0 then
					goto ret_false;
			]
			if op = Bin_Or then [
				if len_greater_than(arg1_blob, 0) and blob_to_int(arg1_blob) = 1 or
				   len_greater_than(arg2_blob, 0) and blob_to_int(arg2_blob) = 1 then
					goto ret_true;
			]
			if op = Bin_Less then [
				if len_greater_than(arg1_blob, 0) and blob_to_int(arg1_blob) = 1 or
				   len_greater_than(arg2_blob, 0) and blob_to_int(arg2_blob) = 0 then
					goto ret_false;
			]
			if op = Bin_LessEqual then [
				if len_greater_than(arg1_blob, 0) and blob_to_int(arg1_blob) = 0 or
				   len_greater_than(arg2_blob, 0) and blob_to_int(arg2_blob) = 1 then
					goto ret_true;
			]
			if op = Bin_Greater then [
				if len_greater_than(arg1_blob, 0) and blob_to_int(arg1_blob) = 0 or
				   len_greater_than(arg2_blob, 0) and blob_to_int(arg2_blob) = 1 then
					goto ret_false;
			]
			if op = Bin_GreaterEqual then [
				if len_greater_than(arg1_blob, 0) and blob_to_int(arg1_blob) = 1 or
				   len_greater_than(arg2_blob, 0) and blob_to_int(arg2_blob) = 0 then
					goto ret_true;
			]
		]
		if not len_greater_than(arg1_blob, 0) or not len_greater_than(arg2_blob, 0) then
			return cc, typ;
		var res := evaluate_binary(t1, t, op, arg1_blob, arg2_blob);
		if is_exception res then
			return cc, typ;
		return empty_compare_context, encode_constant(t, res);
ret_false:
		return empty_compare_context, encode_constant(t, int_to_blob(0));
ret_true:
		return empty_compare_context, encode_constant(t, int_to_blob(1));
	]
	if opcode = P_UnaryOp then [
		var ccx, t := get_deep_type_of_var(cc_ctx, typ);
		var op := pcode_UnaryOp_get_op(instr);
		var arg1 := pcode_UnaryOp_get_arg(instr);
		var ccx1, t1 := get_deep_type_of_var(cc_ctx, arg1);
		var inv : list(compare_argument);
		ccx1, t1, inv := get_type_invariants(ctx, ccx1, t1);
		if not type_is_flat(t) then
			abort internal("get_base_definition: invalid destination type for unary operation " + ntos(op) + ": " + ntos(t));
		if not type_is_flat(t1) then
			abort internal("get_base_definition: invalid source type for unary operation " + ntos(op) + ": " + ntos(t1));
		var arg1_blob := get_constant(arg1);
		if not len_greater_than(arg1_blob, 0) then
			return cc, typ;
		var res := evaluate_unary(t1, t, op, arg1_blob);
		if is_exception res then
			return cc, typ;
		return empty_compare_context, encode_constant(t, res);
	]
	if opcode = P_Option_Load then [
		var arg := pcode_Option_Load_get_option(instr);
		var idx := pcode_Option_Load_get_index(instr);
		var arg_cc, arg_typ := get_base_definition(ctx, cc, arg, false);
		var arg_instr := get_defined_maybe(arg_cc, arg_typ);
		if arg_instr is n then
			return cc, typ;
		if arg_instr.j.opcode <> P_Option_Create then
			return cc, typ;
		if pcode_Option_Create_get_index(arg_instr.j) <> idx then
			return cc, typ;
		cc, typ := arg_cc, pcode_Option_Create_get_arg(arg_instr.j);
		goto restart;
	]
	if opcode = P_Option_Test then [
		var arg := pcode_Option_Test_get_option(instr);
		var idx := pcode_Option_Test_get_index(instr);
		var arg_cc, arg_typ := get_base_definition(ctx, cc, arg, false);
		if not typ_is_const(arg_typ), arg_cc.option_map[arg_typ] >= 0 then [
			return empty_compare_context, encode_constant(T_Bool, int_to_blob(select(arg_cc.option_map[arg_typ] = idx, 0, 1)));
		]
		var arg_instr := get_defined_maybe(arg_cc, arg_typ);
		if arg_instr is n then
			return cc, typ;
		if arg_instr.j.opcode = P_Load_Const then [
			var cnst := blob_to_int(pcode_Load_Const_get_blob(arg_instr.j));
			return empty_compare_context, encode_constant(T_Bool, int_to_blob(select(cnst = idx, 0, 1)));
		]
		if arg_instr.j.opcode = P_Option_Create then [
			var cnst := pcode_Option_Create_get_index(arg_instr.j);
			return empty_compare_context, encode_constant(T_Bool, int_to_blob(select(cnst = idx, 0, 1)));
		]
		return cc, typ;
	]
	if opcode = P_Option_Ord then [
		var arg := pcode_Option_Ord_get_option(instr);
		var cnst : int;
		var arg_cc, arg_typ := get_base_definition(ctx, cc, arg, false);
		if not typ_is_const(arg_typ), arg_cc.option_map[arg_typ] >= 0 then [
			cnst := arg_cc.option_map[arg_typ];
			goto ret_cnst;
		]
		var arg_instr := get_defined_maybe(arg_cc, arg_typ);
		if arg_instr is n then
			return cc, typ;
		if arg_instr.j.opcode = P_Load_Const then [
			cnst := blob_to_int(pcode_Load_Const_get_blob(arg_instr.j));
		] else if arg_instr.j.opcode = P_Option_Create then [
			cnst := pcode_Option_Create_get_index(arg_instr.j);
		] else [
			return cc, typ;
		]
ret_cnst:
		return empty_compare_context, encode_constant(T_Integer, int_to_blob(cnst));
	]

	if opcode = P_Copy_Type_Cast or
	   opcode = P_Value or
	   opcode = P_Where or
	   opcode = P_Curry or
	   opcode = P_Load_Fn or
	   opcode = P_Fn or
	   opcode = P_Structured_Write or
	   opcode = P_Record_Create or
	   opcode = P_Option_Create or
	   opcode = P_Array_Create or
	   opcode = P_Array_String or
	   opcode = P_Array_Unicode or
	   opcode = P_Array_Load or
	   opcode = P_Array_Sub or
	   opcode = P_Array_Skip or
	   opcode = P_Array_Append or
	   opcode = P_IO or
	   opcode = P_ForAll or
	   false then
		return cc, typ;

	abort internal("get_base_definition: invalid opcode " + ntos(opcode));
]

fn get_deep_type_of_var(ctx : function_context, v : int) : (compare_context, int)
[
	var typ := get_type_of_var(ctx, v);
	if typ_is_const(typ) then
		return empty_compare_context, typ;
	var cc := new_compare_context(ctx);
	cc, typ := get_base_definition(ctx, cc, typ, true);
	return cc, typ;
]

fn have_type_invariants(ctx : function_context, cc : compare_context, typ : int) : bool
[
	cc, typ := get_base_definition(ctx, cc, typ, false);
	if typ_is_const(typ) then
		return false;

	var instr := get_defined(cc, typ);
	var opcode := instr.opcode;
	if opcode = P_Where then
		return true;

	return false;
]

fn get_type_invariants(ctx : function_context, cc : compare_context, typ : int) : (compare_context, int, list(compare_argument))
[
	var inv := empty(compare_argument);

again:
	cc, typ := get_base_definition(ctx, cc, typ, false);
	if typ_is_const(typ) then
		return cc, typ, inv;

	var instr := get_defined(cc, typ);
	var opcode := instr.opcode;

	if opcode = P_Where then [
		var sub_type := pcode_Where_get_type(instr);
		var sub_cond := pcode_Where_get_condition(instr);
		inv +<= compare_argument.[ cc : cc, idx : sub_cond ];
		typ := sub_type;
		goto again;
	]

	return cc, typ, inv;
]

fn teq_ret~inline(x : teq) : teq
[
	if x is inferred then
		return x;
	return teq.dont_know;
]

fn teq_ret_noeq~inline(x : teq) : teq
[
	if x is inferred or x is noeq then
		return x;
	return teq.dont_know;
]

fn verify_type_equality(ctx : function_context,
			cc1 : compare_context, typ1 : int, fn_stack1 : list(compare_fn_stack),
			cc2 : compare_context, typ2 : int, fn_stack2 : list(compare_fn_stack)) : teq
[
	if typ1 >= 0, typ1 = typ2, cc1.ctx.incomplete, cc2.ctx.incomplete, cc1.ctx.id = cc2.ctx.id, get_defined_maybe(cc1, typ1) is j then [
		//eval debug("verify_type_equality bypass: " + ntos(typ1));
		return teq.eq;
	]

	cc1, typ1 := get_base_definition(ctx, cc1, typ1, false);
	cc2, typ2 := get_base_definition(ctx, cc2, typ2, false);

	if typ1 = T_UnknownType or typ2 = T_UnknownType then
		return teq.dont_know;

	if typ_is_const(typ1) or typ_is_const(typ2) then [
		if typ1 <= ctx.inferred_base and typ2 <= ctx.inferred_base then
			abort internal("verify_type_equality: both variables are inference markers");
		if typ1 <= ctx.inferred_base then [
			var x_typ : int;
			ctx, x_typ := evaluate_type(ctx, cc2, typ2, empty(compare_fn_stack), empty(token));
			var inferred := inferred_result.[ arg : ctx.inferred_base - typ1, ctx : ctx, typ : x_typ ];
			//eval debug(i_decode(ctx.name) +" inferred1: " + ", " + ntos(typ2) + ", " + ntos(x_typ));
			return teq.inferred.(inferred);
		]
		if typ2 <= ctx.inferred_base then [
			var x_typ : int;
			ctx, x_typ := evaluate_type(ctx, cc1, typ1, empty(compare_fn_stack), empty(token));
			var inferred := inferred_result.[ arg : ctx.inferred_base - typ2, ctx : ctx, typ : x_typ ];
			//eval debug(i_decode(ctx.name) + " inferred2: " + ", " + ntos(typ1) + ", " + ntos(x_typ));
			return teq.inferred.(inferred);
		]
		if typ1 <= T_InferredType or typ2 <= T_InferredType then
			return teq.dont_know;
		if typ1 = typ2 then
			return teq.eq;
		if typ_is_const(typ1), typ_is_const(typ2) then
			return teq.noeq;
		return teq.dont_know;
	]

	if typ1 = typ2, cc1.ctx.incomplete, cc2.ctx.incomplete, cc1.ctx.id = cc2.ctx.id then
		return teq.eq;

	var instr1 := get_defined(cc1, typ1);
	var opcode1 := instr1.opcode;
	var instr2 := get_defined(cc2, typ2);
	var opcode2 := instr2.opcode;

	if opcode1 = P_Call_Indirect, opcode2 = P_Call then [
		opcode1, opcode2 := opcode2, opcode1;
		instr1, instr2 := instr2, instr1;
		typ1, typ2 := typ2, typ1;
		cc1, cc2 := cc2, cc1;
		fn_stack1, fn_stack2 := fn_stack2, fn_stack1;
	]
	if opcode1 = P_Call, opcode2 = P_Call_Indirect then [
		var ret_idx1 := pcode_Call_find_return_index(instr1, typ1);
		var ret_idx2 := pcode_Call_Indirect_find_return_index(instr2, typ2);
		if ret_idx1 <> ret_idx2 then
			return teq.dont_know;

		var args2 := empty(compare_argument);
		var fn2 := pcode_Call_Indirect_get_fn_variable(instr2);
		cc2, typ2 := get_base_definition(ctx, cc2, fn2, false);
		var ins := get_defined_maybe(cc2, typ2);
		while ins is j, ins.j.opcode = P_Curry do [
			instr2 := ins.j;
			for ii := 0 to pcode_Curry_get_n_curried_args(instr2) do [
				var i := pcode_Curry_get_n_curried_args(instr2) - 1 - ii;
				var a := pcode_Curry_get_arg(instr2, i);
				args2 +<= new_compare_argument(cc2, a);
			]
			cc2, typ2 := get_base_definition(ctx, cc2, pcode_Curry_get_fn_variable(instr2), false);
			ins := get_defined_maybe(cc2, typ2);
		]

		if not (ins is j and ins.j.opcode = P_Load_Fn) then [
			if typ2 <= ctx.inferred_base, pcode_Call_get_n_args(instr1) >= len(args2) then [
				var fid1 := pcode_Call_get_unique_id(instr1);
				var fd1 := search_function_from_id(ctx, fid1);
				var x_typ : int;
				ctx, x_typ := generate_Load_Fn(ctx, fd1, empty(token));
				if pcode_Call_get_n_args(instr1) > len(args2) then [
					var iargs := empty(int);
					var flags := empty(int);
					for i := 0 to pcode_Call_get_n_args(instr1) - len(args2) do [
						var iarg : int;
						ctx, iarg := evaluate_type(ctx, cc1, pcode_Call_get_arg(instr1, i), empty(compare_fn_stack), empty(token));
						iargs +<= iarg;
						flags +<= pcode_Call_get_flag(instr1, i);
					]
					var cc, typ := get_deep_type_of_var(ctx, x_typ);
					ctx, x_typ := generate_Curry(ctx, cc, typ, x_typ, iargs, flags, empty(token));
				]
				var inferred := inferred_result.[ arg : ctx.inferred_base - typ2, ctx : ctx, typ : x_typ ];
				return teq.inferred.(inferred);
			]
			return teq.dont_know;
		]
		instr2 := ins.j;

		var fid1 := pcode_Call_get_unique_id(instr1);
		var fid2 := pcode_Load_Fn_get_unique_id(instr2);
		if fid1 <> fid2 then
			return teq.dont_know;

		if pcode_Call_get_n_args(instr1) <> len(args2) then
			abort internal("verify_type_equality: the number of arguments doesn't match: " + ntos(pcode_Call_get_n_args(instr1)) + ", " + ntos(len(args2)));

		for i := 0 to len(args2) do [
			var arg_idx := len(args2) - 1 - i;
			var x1 := verify_type_equality(ctx, cc1, pcode_Call_get_arg(instr1, i), fn_stack1,
							    args2[arg_idx].cc, args2[arg_idx].idx, fn_stack2);
			if not x1 is eq then
				return teq_ret(x1);
		]
		return teq.eq;
	]

	if cc1.option_map[typ1] >= 0 then [
		var def1 := get_record_or_option(ctx, cc1, typ1, true);
		if def1.entries[cc1.option_map[typ1]].type_idx = T_EmptyOption then
			opcode1 := P_Load_Const;
	]
	if cc2.option_map[typ2] >= 0 then [
		var def2 := get_record_or_option(ctx, cc2, typ2, true);
		if def2.entries[cc2.option_map[typ2]].type_idx = T_EmptyOption then
			opcode2 := P_Load_Const;
	]

	if opcode1 <> opcode2 then
		return teq.dont_know;

	if opcode1 = P_Copy then
		return teq.dont_know;

	if opcode1 = P_BinaryOp then [
		if pcode_BinaryOp_get_op(instr1) <> pcode_BinaryOp_get_op(instr2) then
			return teq.dont_know;
		var a1 := pcode_BinaryOp_get_arg1(instr1);
		var a2 := pcode_BinaryOp_get_arg1(instr2);
		var x := verify_type_equality(ctx, cc1, a1, fn_stack1, cc2, a2, fn_stack2);
		if not x is eq then
			return teq_ret(x);
		a1 := pcode_BinaryOp_get_arg2(instr1);
		a2 := pcode_BinaryOp_get_arg2(instr2);
		x := verify_type_equality(ctx, cc1, a1, fn_stack1, cc2, a2, fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]

	if opcode1 = P_UnaryOp then [
		if pcode_UnaryOp_get_op(instr1) <> pcode_UnaryOp_get_op(instr2) then
			return teq.dont_know;
		if pcode_UnaryOp_get_op(instr1) = Un_ConvertFromInt then [
			var r1 := pcode_UnaryOp_get_result(instr1);
			var r2 := pcode_UnaryOp_get_result(instr2);
			if get_type_of_var(cc1.ctx, r1) <> get_type_of_var(cc2.ctx, r2) then
				return teq.dont_know;
		]
		var a1 := pcode_UnaryOp_get_arg(instr1);
		var a2 := pcode_UnaryOp_get_arg(instr2);
		var x := verify_type_equality(ctx, cc1, a1, fn_stack1, cc2, a2, fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]

	if opcode1 = P_Value then [
		return teq.eq;
	]

	if opcode1 = P_Where then [
		var ty1 := pcode_Where_get_type(instr1);
		var ty2 := pcode_Where_get_type(instr2);
		var x := verify_type_equality(ctx, cc1, ty1, fn_stack1, cc2, ty2, fn_stack2);
		if not x is eq then
			return teq_ret(x);
		var cond1 := pcode_Where_get_condition(instr1);
		var cond2 := pcode_Where_get_condition(instr2);
		x := verify_type_equality(ctx, cc1, cond1, fn_stack1, cc2, cond2, fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]

	if opcode1 = P_Fn then [
		if pcode_Fn_get_n_args(instr1) <> pcode_Fn_get_n_args(instr2) or
		   pcode_Fn_get_n_return_values(instr1) <> pcode_Fn_get_n_return_values(instr2) or
		   pcode_Fn_get_n_prereqs(instr1) <> pcode_Fn_get_n_prereqs(instr2) or
		   pcode_Fn_get_n_contracts(instr1) <> pcode_Fn_get_n_contracts(instr2) then
			return teq.dont_know;
		var new_fn_stack1 : compare_fn_stack := compare_fn_stack.[
			cc : cc1,
			main_def : pcode_Fn_get_result(instr1),
			dest_def : exception_make(int, ec_sync, error_record_field_not_initialized, 0, false),
			dest_types : exception_make(list(int), ec_sync, error_record_field_not_initialized, 0, false),
		];
		fn_stack1 +<= new_fn_stack1;
		var new_fn_stack2 : compare_fn_stack := compare_fn_stack.[
			cc : cc2,
			main_def : pcode_Fn_get_result(instr2),
			dest_def : exception_make(int, ec_sync, error_record_field_not_initialized, 0, false),
			dest_types : exception_make(list(int), ec_sync, error_record_field_not_initialized, 0, false),
		];
		fn_stack2 +<= new_fn_stack2;
		for i := 0 to pcode_Fn_get_n_args(instr1) do [
			var a1 := pcode_Fn_get_argument(instr1, i);
			var a2 := pcode_Fn_get_argument(instr2, i);
			var x := verify_type_equality(ctx, cc1, a1, fn_stack1, cc2, a2, fn_stack2);
			if not x is eq then
				return teq_ret(x);
		]
		for i := 0 to pcode_Fn_get_n_return_values(instr1) do [
			var a1 := pcode_Fn_get_return_value(instr1, i);
			var a2 := pcode_Fn_get_return_value(instr2, i);
			var x := verify_type_equality(ctx, cc1, a1, fn_stack1, cc2, a2, fn_stack2);
			if not x is eq then
				return teq_ret(x);
		]
		for i := 0 to pcode_Fn_get_n_prereqs(instr1) do [
			var a1 := pcode_Fn_get_prereq(instr1, i);
			var a2 := pcode_Fn_get_prereq(instr2, i);
			var x := verify_type_equality(ctx, cc1, a1, fn_stack1, cc2, a2, fn_stack2);
			if not x is eq then
				return teq_ret(x);
		]
		for i := 0 to pcode_Fn_get_n_contracts(instr1) do [
			var a1 := pcode_Fn_get_contract(instr1, i);
			var a2 := pcode_Fn_get_contract(instr2, i);
			var x := verify_type_equality(ctx, cc1, a1, fn_stack1, cc2, a2, fn_stack2);
			if not x is eq then
				return teq_ret(x);
		]
		return teq.eq;
	]
	if opcode1 = P_Load_Local_Type then [
		var s1, d1 := find_fn_stack_depth(fn_stack1, cc1, pcode_Load_Local_Type_get_function(instr1));
		var s2, d2 := find_fn_stack_depth(fn_stack2, cc2, pcode_Load_Local_Type_get_function(instr2));
		if d1 < 0 or d2 < 0 then [
			var x := verify_type_equality(ctx, cc1, pcode_Load_Local_Type_get_function(instr1), fn_stack1, cc2, pcode_Load_Local_Type_get_function(instr2), fn_stack2);
			if not x is eq then
				return teq_ret(x);
		]
		if d1 = d2 and pcode_Load_Local_Type_get_index(instr1) = pcode_Load_Local_Type_get_index(instr2) then
			return teq.eq;
		return teq.dont_know;
	]

	if opcode1 = P_Load_Fn then [
		var id1 := pcode_Load_Fn_get_unique_id(instr1);
		var id2 := pcode_Load_Fn_get_unique_id(instr2);
		if id1 <> id2 then
			return teq.noeq;
		return teq.eq;
	]
	if opcode1 = P_Curry then [
		var args1 := empty(compare_argument);
		while true do [
			for ii := 0 to pcode_Curry_get_n_curried_args(instr1) do [
				var i := pcode_Curry_get_n_curried_args(instr1) - 1 - ii;
				var a := pcode_Curry_get_arg(instr1, i);
				args1 +<= new_compare_argument(cc1, a);
			]
			cc1, typ1 := get_base_definition(ctx, cc1, pcode_Curry_get_fn_variable(instr1), false);
			var ins := get_defined_maybe(cc1, typ1);
			if ins is j, ins.j.opcode = P_Curry then [
				instr1 := ins.j;
				continue;
			]
			break;
		]
		var args2 := empty(compare_argument);
		while true do [
			for ii := 0 to pcode_Curry_get_n_curried_args(instr2) do [
				var i := pcode_Curry_get_n_curried_args(instr2) - 1 - ii;
				var a := pcode_Curry_get_arg(instr2, i);
				args2 +<= new_compare_argument(cc2, a);
			]
			cc2, typ2 := get_base_definition(ctx, cc2, pcode_Curry_get_fn_variable(instr2), false);
			var ins := get_defined_maybe(cc2, typ2);
			if ins is j, ins.j.opcode = P_Curry then [
				instr2 := ins.j;
				continue;
			]
			break;
		]
		if len(args1) <> len(args2) then [
			if typ1 <= ctx.inferred_base then [
				opcode1, opcode2 := opcode2, opcode1;
				instr1, instr2 := instr2, instr1;
				typ1, typ2 := typ2, typ1;
				cc1, cc2 := cc2, cc1;
				fn_stack1, fn_stack2 := fn_stack2, fn_stack1;
				args1, args2 := args2, args1;
			]
			if typ2 <= ctx.inferred_base, len(args1) > len(args2) then [
				var x_typ : int;
				ctx, x_typ := evaluate_type(ctx, cc1, typ1, empty(compare_fn_stack), empty(token));
				for i := 0 to len(args2) do [
					var x1 := verify_type_equality(ctx, args1[i].cc, args1[i].idx, fn_stack1, args2[i].cc, args2[i].idx, fn_stack2);
					if not x1 is eq then
						return teq_ret(x1);
				]
				var iargs := empty(int);
				for i := len(args2) to len(args1) do [
					var iarg : int;
					ctx, iarg := evaluate_type(ctx, args1[i].cc, args1[i].idx, empty(compare_fn_stack), empty(token));
					iargs := [ iarg ] + iargs;
				]
				var cc, typ := get_deep_type_of_var(ctx, x_typ);
				ctx, x_typ := generate_Curry(ctx, cc, typ, x_typ, iargs, fill(0, len(iargs)), empty(token));
				var inferred := inferred_result.[ arg : ctx.inferred_base - typ2, ctx : ctx, typ : x_typ ];
				return teq.inferred.(inferred);
			]
			return teq.dont_know;
		]
		var x1 := verify_type_equality(ctx, cc1, typ1, fn_stack1, cc2, typ2, fn_stack2);
		if not x1 is eq then
			return teq_ret(x1);
		for i := 0 to len(args1) do [
			var x1 := verify_type_equality(ctx, args1[i].cc, args1[i].idx, fn_stack1, args2[i].cc, args2[i].idx, fn_stack2);
			if not x1 is eq then
				return teq_ret(x1);
		]
		return teq.eq;
	]
	if opcode1 = P_Call_Indirect then [
		if pcode_Call_Indirect_get_n_args(instr1) <> 0 then
			abort internal("verify_type_equality: Call_Indirect with arguments");
		if pcode_Call_Indirect_get_n_args(instr2) <> 0 then
			abort internal("verify_type_equality: Call_Indirect with arguments");
		var ret_idx1 := pcode_Call_Indirect_find_return_index(instr1, typ1);
		var ret_idx2 := pcode_Call_Indirect_find_return_index(instr2, typ2);
		if ret_idx1 <> ret_idx2 then
			return teq.dont_know;
		var fn1 := pcode_Call_Indirect_get_fn_variable(instr1);
		var fn2 := pcode_Call_Indirect_get_fn_variable(instr2);
		var x := verify_type_equality(ctx, cc1, fn1, fn_stack1, cc2, fn2, fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]
	if opcode1 = P_Call then [
		if pcode_Call_quick_compare(instr1, instr2) then
			return teq.dont_know;
		var fid1 := pcode_Call_get_unique_id(instr1);
		var fid2 := pcode_Call_get_unique_id(instr2);
		if fid1 <> fid2 then
			return teq.dont_know;
		var ret_idx1 := pcode_Call_find_return_index(instr1, typ1);
		var ret_idx2 := pcode_Call_find_return_index(instr2, typ2);
		if ret_idx1 <> ret_idx2 then
			return teq.dont_know;
		for i := 0 to pcode_Call_get_n_args(instr1) do [
			var x1 := verify_type_equality(ctx, cc1, pcode_Call_get_arg(instr1, i), fn_stack1,
							    cc2, pcode_Call_get_arg(instr2, i), fn_stack2);
			if not x1 is eq then
				return teq_ret(x1);
		]
		return teq.eq;
	]
	if opcode1 = P_Load_Const then [
		var val1 val2 : list(pcode_t);
		if instr1.opcode = P_Load_Const then
			val1 := pcode_Load_Const_get_blob(instr1);
		else
			val1 := int_to_blob(cc1.option_map[typ1]);
		if instr2.opcode = P_Load_Const then
			val2 := pcode_Load_Const_get_blob(instr2);
		else
			val2 := int_to_blob(cc2.option_map[typ2]);
		if val1 <> val2 then
			return teq.noeq;
		return teq.eq;
	]
	if opcode1 = P_Record_Create then [
		var type_idx1 := cc1.ctx.variables[typ1].type_idx;
		var type_idx2 := cc2.ctx.variables[typ2].type_idx;
		var def1 := get_record_or_option(ctx, cc1, typ1, false);
		var def2 := get_record_or_option(ctx, cc2, typ2, false);
		var x1 := verify_type_equality(ctx, cc1, type_idx1, fn_stack1, cc2, type_idx2, fn_stack2);
		if not x1 is eq then
			return teq_ret_noeq(x1);
		if len(def1.entries) <> len(def2.entries) then
			return teq.noeq;
		if len(def1.entries) <> pcode_Record_Create_get_n_args(instr1) or
		   len(def2.entries) <> pcode_Record_Create_get_n_args(instr2) then
			abort internal("verify_type_equality: Non-matching number of entries");
		for i := 0 to len(def1.entries) do [
			var x1 := verify_type_equality(ctx, cc1, pcode_Record_Create_get_arg(instr1, i), fn_stack1, cc2, pcode_Record_Create_get_arg(instr2, i), fn_stack2);
			if not x1 is eq then
				return teq_ret_noeq(x1);
		]
		return teq.eq;
	]
	if opcode1 = P_Record_Load then [
		var idx1 := pcode_Record_Load_get_index(instr1);
		var idx2 := pcode_Record_Load_get_index(instr2);
		if idx1 <> idx2 then
			return teq.dont_know;
		if cc1.ctx.incomplete, cc2.ctx.incomplete, cc1.ctx.id = cc2.ctx.id, pcode_Record_Load_get_record(instr1) = pcode_Record_Load_get_record(instr2), cc1.ctx.variables[pcode_Record_Load_get_record(instr1)].defined_at <> defined_multiple then [
			var type_idx1 := pcode_Record_Load_get_record(instr1);
			var def1 := get_record_or_option(ctx, cc1, type_idx1, false);
			if def1.entries[idx1].cnst then
				return teq.eq;
		]
		var x := verify_type_equality(ctx, cc1, pcode_Record_Load_get_record(instr1), fn_stack1,
						   cc2, pcode_Record_Load_get_record(instr2), fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]
	if opcode1 = P_Option_Create then [
		if pcode_Option_Create_get_index(instr1) <> pcode_Option_Create_get_index(instr2) then
			return teq.noeq;
		var x := verify_type_equality(ctx, cc1, pcode_Option_Create_get_arg(instr1), fn_stack1,
						   cc2, pcode_Option_Create_get_arg(instr2), fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]
	if opcode1 = P_Option_Load then [
		var idx1 := pcode_Option_Load_get_index(instr1);
		var idx2 := pcode_Option_Load_get_index(instr2);
		if idx1 <> idx2 then
			return teq.dont_know;
		var x := verify_type_equality(ctx, cc1, pcode_Option_Load_get_option(instr1), fn_stack1,
						   cc2, pcode_Option_Load_get_option(instr2), fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]
	if opcode1 = P_Option_Test then [
		var idx1 := pcode_Option_Test_get_index(instr1);
		var idx2 := pcode_Option_Test_get_index(instr2);
		if idx1 <> idx2 then
			return teq.dont_know;
		var x := verify_type_equality(ctx, cc1, pcode_Option_Test_get_option(instr1), fn_stack1,
						   cc2, pcode_Option_Test_get_option(instr2), fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]
	if opcode1 = P_Option_Ord then [
		var x := verify_type_equality(ctx, cc1, pcode_Option_Ord_get_option(instr1), fn_stack1,
						   cc2, pcode_Option_Ord_get_option(instr2), fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]
	if opcode1 = P_Array_Create then [
		if pcode_Array_Create_get_length(instr1) <> pcode_Array_Create_get_length(instr2) then
			return teq.noeq;
		for i := 0 to pcode_Array_Create_get_length(instr1) do [
			var x1 := verify_type_equality(ctx, cc1, pcode_Array_Create_get_arg(instr1, i), fn_stack1,
							    cc2, pcode_Array_Create_get_arg(instr2, i), fn_stack2);
			if not x1 is eq then
				return teq_ret_noeq(x1);
		]
		return teq.eq;
	]
	if opcode1 = P_Array_String then [
		var blob1 := pcode_Array_String_get_blob(instr1);
		var blob2 := pcode_Array_String_get_blob(instr2);
		if blob1 <> blob2 then
			return teq.noeq;
		return teq.eq;
	]
	if opcode1 = P_Array_Unicode then [
		var blob1 := pcode_Array_Unicode_get_blob(instr1);
		var blob2 := pcode_Array_Unicode_get_blob(instr2);
		if blob1 <> blob2 then
			return teq.noeq;
		return teq.eq;
	]
	if opcode1 = P_Array_Load then [
		var a1 := pcode_Array_Load_get_array(instr1);
		var a2 := pcode_Array_Load_get_array(instr2);
		var idx1 := pcode_Array_Load_get_index(instr1);
		var idx2 := pcode_Array_Load_get_index(instr2);
		var x1 := verify_type_equality(ctx, cc1, a1, fn_stack1,
						    cc2, a2, fn_stack2);
		if not x1 is eq then
			return teq_ret(x1);
		var x2 := verify_type_equality(ctx, cc1, idx1, fn_stack1,
						    cc2, idx2, fn_stack2);
		if not x2 is eq then
			return teq_ret(x2);
		return teq.eq;
	]
	if opcode1 = P_Array_Sub then [
		var x1 := verify_type_equality(ctx, cc1, pcode_Array_Sub_get_array(instr1), fn_stack1,
						    cc2, pcode_Array_Sub_get_array(instr2), fn_stack2);
		if not x1 is eq then
			return teq_ret(x1);
		var x2 := verify_type_equality(ctx, cc1, pcode_Array_Sub_get_start(instr1), fn_stack1,
						    cc2, pcode_Array_Sub_get_start(instr2), fn_stack2);
		if not x2 is eq then
			return teq_ret(x2);
		var x3 := verify_type_equality(ctx, cc1, pcode_Array_Sub_get_end(instr1), fn_stack1,
						    cc2, pcode_Array_Sub_get_end(instr2), fn_stack2);
		if not x3 is eq then
			return teq_ret(x3);
		return teq.eq;
	]
	if opcode1 = P_Array_Skip then [
		var x1 := verify_type_equality(ctx, cc1, pcode_Array_Skip_get_array(instr1), fn_stack1,
						    cc2, pcode_Array_Skip_get_array(instr2), fn_stack2);
		if not x1 is eq then
			return teq_ret(x1);
		var x2 := verify_type_equality(ctx, cc1, pcode_Array_Skip_get_start(instr1), fn_stack1,
						    cc2, pcode_Array_Skip_get_start(instr2), fn_stack2);
		if not x2 is eq then
			return teq_ret(x2);
		return teq.eq;
	]
{
	if opcode1 = P_Array_Append then [
		abort unimplemented("verify_type_equality: P_Array_Append");
	]
}
	if opcode1 = P_Copy_Type_Cast then [
		return teq.dont_know;
	]
	if opcode1 = P_IO then [
		return teq.dont_know;
	]

	if opcode1 = P_Args then [
		return teq.dont_know;
	]
	if opcode1 = P_ForAll then [
		var new_fn_stack1 : compare_fn_stack := compare_fn_stack.[
			cc : cc1,
			main_def : pcode_ForAll_get_result(instr1),
			dest_def : exception_make(int, ec_sync, error_record_field_not_initialized, 0, false),
			dest_types : exception_make(list(int), ec_sync, error_record_field_not_initialized, 0, false),
		];
		fn_stack1 +<= new_fn_stack1;
		var new_fn_stack2 : compare_fn_stack := compare_fn_stack.[
			cc : cc2,
			main_def : pcode_ForAll_get_result(instr2),
			dest_def : exception_make(int, ec_sync, error_record_field_not_initialized, 0, false),
			dest_types : exception_make(list(int), ec_sync, error_record_field_not_initialized, 0, false),
		];
		fn_stack2 +<= new_fn_stack2;
		var x := verify_type_equality(ctx, cc1, pcode_ForAll_get_type(instr1), fn_stack1, cc2, pcode_ForAll_get_type(instr2), fn_stack2);
		if not x is eq then
			return teq_ret(x);
		x := verify_type_equality(ctx, cc1, pcode_ForAll_get_condition(instr1), fn_stack1, cc2, pcode_ForAll_get_condition(instr2), fn_stack2);
		if not x is eq then
			return teq_ret(x);
		return teq.eq;
	]

	abort internal("verify_type_equality: invalid opcode " + ntos(opcode1));
]

fn evaluate_type(ctx : function_context, cc : compare_context, typ : int, fn_stack : list(compare_fn_stack), t : tokens) : (function_context, int)
[
	cc, typ := get_base_definition(ctx, cc, typ, false);

	if typ = T_UnknownType then
		abort compiler_error("Only constants may be used in type definitions", t);

	if typ <= T_InferredType then
		abort compiler_error("Referencing argument that is not yet inferred", t);

	if typ < 0 then
		return ctx, typ;

	if typ_is_const(typ) then [
		var tp, pc := decode_constant(typ);
		var l : int;
		ctx, l := generate_Load_Const(ctx, tp, pc);
		return ctx, l;
	]

	var cc_ctx := cc.ctx;

	if cc.option_map[typ] >= 0 then [
		var idx := cc.option_map[typ];
		var def := get_record_or_option(ctx, cc, typ, true);
		if def.entries[idx].type_idx = T_EmptyOption then [
			var type_idx := get_type_of_var(cc_ctx, typ);
			var at : int;
			ctx, at := evaluate_type(ctx, cc, type_idx, fn_stack, t);
			var l : int;
			ctx, l := generate_Load_Const(ctx, at, int_to_blob(idx));
			return ctx, l;
		]
	]

	{*
	 * !!! FIXME: dirty HACK
	 * if we are called from generate_Load_Fn, we must shortcut local variables due to Load_Local_Type
	 * if we are called from generate_Curry or generate_Call_Indirect, we must not shortcut local variables due to Load_Local_Type
	 *}
	if cc.root and cc.llt_main is n and ctx.getting_dependencies < 0 and ctx.parsing_where = T_InvalidType then
		return ctx, typ;

	var instr := get_defined(cc, typ);
	var opcode := instr.opcode;

	if (opcode = P_Copy or opcode = P_Args) and cc.root then
		return ctx, typ;

	if opcode = P_BinaryOp then [
		if is_non_const(ctx, cc, pcode_BinaryOp_get_arg1(instr)) or
		   is_non_const(ctx, cc, pcode_BinaryOp_get_arg2(instr)) then
			goto uses_non_const;
		var a1 a2 : int;
		ctx, a1 := evaluate_type(ctx, cc, pcode_BinaryOp_get_arg1(instr), fn_stack, t);
		ctx, a2 := evaluate_type(ctx, cc, pcode_BinaryOp_get_arg2(instr), fn_stack, t);
		var rtyp : int;
		ctx, rtyp := evaluate_type(ctx, cc, get_type_of_var(cc.ctx, pcode_BinaryOp_get_result(instr)), fn_stack, t);
		var l : int;
		ctx, l := alloc_local_variable(ctx, rtyp, true, false);
		ctx := generate_BinaryOp(ctx, pcode_BinaryOp_get_op(instr), a1, a2, l);
		return ctx, l;
	]
	if opcode = P_UnaryOp then [
		if is_non_const(ctx, cc, pcode_UnaryOp_get_arg(instr)) then
			goto uses_non_const;
		var a1 : int;
		ctx, a1 := evaluate_type(ctx, cc, pcode_UnaryOp_get_arg(instr), fn_stack, t);
		var rtyp : int;
		ctx, rtyp := evaluate_type(ctx, cc, get_type_of_var(cc.ctx, pcode_UnaryOp_get_result(instr)), fn_stack, t);
		var l : int;
		ctx, l := alloc_local_variable(ctx, rtyp, true, false);
		ctx := generate_UnaryOp(ctx, pcode_UnaryOp_get_op(instr), a1, l);
		return ctx, l;
	]
	if opcode = P_Where then [
		var ty : int;
		ctx, ty := evaluate_type(ctx, cc, pcode_Where_get_type(instr), fn_stack, t);
		var va : int;
		ctx, va := generate_Value(ctx, ty);
		var cond : int;
		var pw := ctx.parsing_where;
		ctx.parsing_where := va;
		ctx, cond := evaluate_type(ctx, cc, pcode_Where_get_condition(instr), fn_stack, t);
		ctx.parsing_where := pw;
		var l : int;
		ctx, l := generate_Where(ctx, ty, cond);
		return ctx, l;
	]
	if opcode = P_Value then [
		if ctx.parsing_where = T_InvalidType then
			abort internal("Value out of where");
		return ctx, ctx.parsing_where;
	]
	if opcode = P_Fn then [
		var n_arguments := pcode_Fn_get_n_args(instr);
		var n_return_values := pcode_Fn_get_n_return_values(instr);
		var n_prereqs := pcode_Fn_get_n_prereqs(instr);
		var n_contracts := pcode_Fn_get_n_contracts(instr);
		for i := 0 to n_arguments do
			if is_non_const(ctx, cc, pcode_Fn_get_argument(instr, i)) then
				goto uses_non_const;
		for i := 0 to n_return_values do
			if is_non_const(ctx, cc, pcode_Fn_get_return_value(instr, i)) then
				goto uses_non_const;
		for i := 0 to n_prereqs do
			if is_non_const(ctx, cc, pcode_Fn_get_prereq(instr, i)) then
				goto uses_non_const;
		for i := 0 to n_contracts do
			if is_non_const(ctx, cc, pcode_Fn_get_contract(instr, i)) then
				goto uses_non_const;
		var l : int;
		ctx, l := alloc_local_variable(ctx, T_Type, true, false);
		var args := empty(int);
		var return_values := empty(int);
		var prereqs := empty(int);
		var contracts := empty(int);
		var new_fn_stack : compare_fn_stack := compare_fn_stack.[
			cc : cc,
			main_def : pcode_Fn_get_result(instr),
			dest_def : l,
			dest_types : empty(int),
		];
		fn_stack +<= new_fn_stack;
		for i := 0 to n_arguments do [
			var arg := pcode_Fn_get_argument(instr, i);
			var a1 : int;
			ctx, a1 := evaluate_type(ctx, cc, arg, fn_stack, t);
			args +<= a1;
			fn_stack[len(fn_stack) - 1].dest_types +<= a1;
		]
		for i := 0 to n_return_values do [
			var arg := pcode_Fn_get_return_value(instr, i);
			var a1 : int;
			ctx, a1 := evaluate_type(ctx, cc, arg, fn_stack, t);
			return_values +<= a1;
			fn_stack[len(fn_stack) - 1].dest_types +<= a1;
		]
		for i := 0 to n_prereqs do [
			var arg := pcode_Fn_get_prereq(instr, i);
			var a1 : int;
			ctx, a1 := evaluate_type(ctx, cc, arg, fn_stack, t);
			prereqs +<= a1;
			fn_stack[len(fn_stack) - 1].dest_types +<= a1;
		]
		for i := 0 to n_contracts do [
			var arg := pcode_Fn_get_contract(instr, i);
			var a1 : int;
			ctx, a1 := evaluate_type(ctx, cc, arg, fn_stack, t);
			contracts +<= a1;
			fn_stack[len(fn_stack) - 1].dest_types +<= a1;
		]
		ctx := set_defined_here(ctx, l);
		ctx := generate_Fn(ctx, args, return_values, prereqs, contracts, l);
		return ctx, l;
	]
	if opcode = P_Load_Local_Type then [
		if cc.llt_main is j, pcode_Load_Local_Type_get_function(instr) = cc.llt_main.j, ctx.getting_dependencies >= 0 then [
			ctx.getting_dependencies bts= pcode_Load_Local_Type_get_index(instr);
			return ctx, T_Type;
		]
		var s, d := find_fn_stack_depth(fn_stack, cc, pcode_Load_Local_Type_get_function(instr));
		if d = -1 then
			abort internal("find_fn_stack_depth: Fn definition not found");
		var l : int;
		ctx, l := alloc_local_variable(ctx, s.dest_types[pcode_Load_Local_Type_get_index(instr)], true, false);
		ctx := generate_Load_Local_Type(ctx, s.dest_def, pcode_Load_Local_Type_get_index(instr), l);
		return ctx, l;
	]
	if opcode = P_Load_Fn then [
		var id := pcode_Load_Fn_get_unique_id(instr);
		var fd := search_function_from_id(ctx, id);
		return generate_Load_Fn(ctx, fd, t);
	]
	if opcode = P_Curry then [
		var fnx := pcode_Curry_get_fn_variable(instr);
		if is_non_const(ctx, cc, fnx) then
			goto uses_non_const;
		for i := 0 to pcode_Curry_get_n_curried_args(instr) do
			if is_non_const(ctx, cc, pcode_Curry_get_arg(instr, i)) then
				goto uses_non_const;
		var af : int;
		ctx, af := evaluate_type(ctx, cc, fnx, fn_stack, t);
		var fn_cc, fn_typ := get_deep_type_of_var(ctx, af);
		fn_cc := set_llt_main(fn_cc, fn_typ);
		var my_cc := new_compare_context(ctx);
		var args_idx := empty(int);
		var flags := empty(int);
		for i := 0 to pcode_Curry_get_n_curried_args(instr) do [
			var arg := pcode_Curry_get_arg(instr, i);
			var a1 : int;
			ctx, a1 := evaluate_type(ctx, cc, arg, fn_stack, t);
			args_idx +<= a1;
			flags +<= pcode_Curry_get_flag(instr, i);
			fn_cc.llt_redirect +<= new_compare_argument(my_cc, a1);
			// TODO: quadratic complexity
			// is this really needed?
			for j := 0 to i + 1 do [
				fn_cc.llt_redirect[j].cc.ctx := ctx;
			]
		]
		var l : int;
		ctx, l := generate_Curry(ctx, fn_cc, fn_typ, af, args_idx, flags, t);
		return ctx, l;
	]
	if opcode = P_Call_Indirect then [
		if pcode_Call_Indirect_get_n_args(instr) <> 0 then
			abort internal("evaluate_type: Call_Indirect with arguments");
		var fnx := pcode_Call_Indirect_get_fn_variable(instr);
		if is_non_const(ctx, cc, fnx) then
			goto uses_non_const;
		var af : int;
		ctx, af := evaluate_type(ctx, cc, fnx, fn_stack, t);
		var rv : list(int);
		ctx, rv := generate_Call_Indirect(ctx, Call_Mode_Unspecified, af, t);
		var ret_idx := pcode_Call_Indirect_find_return_index(instr, typ);
		return ctx, rv[ret_idx];
	]
	if opcode = P_Call then [
		for i := 0 to pcode_Call_get_n_args(instr) do
			if is_non_const(ctx, cc, pcode_Call_get_arg(instr, i)) then
				goto uses_non_const;
		var id := pcode_Call_get_unique_id(instr);
		var fd := search_function_from_id(ctx, id);
		var args := empty(int);
		var flags := empty(int);
		for i := 0 to pcode_Call_get_n_args(instr) do [
			var arg := pcode_Call_get_arg(instr, i);
			var a1 : int;
			ctx, a1 := evaluate_type(ctx, cc, arg, fn_stack, t);
			args +<= a1;
			flags +<= pcode_Call_get_flag(instr, i);
		]
		var rv : list(int);
		ctx, rv := generate_Call(ctx, Call_Mode_Unspecified, fd, args, flags, t);
		var ret_idx := pcode_Call_find_return_index(instr, typ);
		return ctx, rv[ret_idx];
	]
	if opcode = P_Load_Const then [
		var type_idx := get_type_of_var(cc_ctx, typ);
		var at : int;
		ctx, at := evaluate_type(ctx, cc, type_idx, fn_stack, t);
		var l : int;
		ctx, l := generate_Load_Const(ctx, at, pcode_Load_Const_get_blob(instr));
		return ctx, l;
	]
	if opcode = P_Record_Create then [
		for i := 0 to pcode_Record_Create_get_n_args(instr) do
			if is_non_const(ctx, cc, pcode_Record_Create_get_arg(instr, i)) then
				goto uses_non_const;
		var def := get_record_or_option(ctx, cc, typ, false);
		var type_idx := cc_ctx.variables[typ].type_idx;
		if len(def.entries) <> pcode_Record_Create_get_n_args(instr) then
			abort internal("Non-matching record definitions");
		var at : int;
		ctx, at := evaluate_type(ctx, cc, type_idx, fn_stack, t);
		var fields := fill(T_InvalidType, pcode_Record_Create_get_n_args(instr));
		for i := 0 to len(fields) do
			ctx, fields[i] := evaluate_type(ctx, cc, pcode_Record_Create_get_arg(instr, i), fn_stack, t);
		var l : int;
		ctx, l := generate_Record_Create(ctx, at, fields);
		return ctx, l;
	]
	if opcode = P_Record_Load then [
		if cc.root, cc.ctx.variables[pcode_Record_Load_get_record(instr)].mut then
			return ctx, typ;
		if is_non_const(ctx, cc, pcode_Record_Load_get_record(instr)) then
			goto uses_non_const;
		var at : int;
		ctx, at := evaluate_type(ctx, cc, pcode_Record_Load_get_record(instr), fn_stack, t);
		var l : int;
		ctx, l := generate_Record_Load(ctx, at, pcode_Record_Load_get_index(instr), t);
		return ctx, l;
	]
	if opcode = P_Option_Create then [
		var type_idx := cc_ctx.variables[typ].type_idx;
		var at ar l : int;
		ctx, at := evaluate_type(ctx, cc, type_idx, fn_stack, t);
		ctx, ar := evaluate_type(ctx, cc, pcode_Option_Create_get_arg(instr), fn_stack, t);
		ctx, l := generate_Option_Create(ctx, at, pcode_Option_Create_get_index(instr), ar);
		return ctx, l;
	]
	if opcode = P_Option_Load then [
		if is_non_const(ctx, cc, pcode_Option_Load_get_option(instr)) then
			goto uses_non_const;
		var at : int;
		ctx, at := evaluate_type(ctx, cc, pcode_Option_Load_get_option(instr), fn_stack, t);
		var l : int;
		ctx, l := generate_Option_Load(ctx, at, pcode_Option_Load_get_index(instr), t);
		return ctx, l;
	]
	if opcode = P_Option_Test then [
		if is_non_const(ctx, cc, pcode_Option_Test_get_option(instr)) then
			goto uses_non_const;
		var at : int;
		ctx, at := evaluate_type(ctx, cc, pcode_Option_Test_get_option(instr), fn_stack, t);
		var l : int;
		ctx, l := generate_Option_Test(ctx, at, pcode_Option_Test_get_index(instr));
		return ctx, l;
	]
	if opcode = P_Option_Ord then [
		if is_non_const(ctx, cc, pcode_Option_Ord_get_option(instr)) then
			goto uses_non_const;
		var at l : int;
		ctx, at := evaluate_type(ctx, cc, pcode_Option_Ord_get_option(instr), fn_stack, t);
		ctx, l := generate_Option_Ord(ctx, at);
		return ctx, l;
	]
	if opcode = P_Array_Create then [
		var type_idx := cc_ctx.variables[typ].type_idx;
		if is_non_const(ctx, cc, type_idx) then
			goto uses_non_const;
		var array_length := pcode_Array_Create_get_length(instr);
		for i := 0 to array_length do
			if is_non_const(ctx, cc, pcode_Array_Create_get_arg(instr, i)) then
				goto uses_non_const;
		var at elem length l : int;
		ctx, at := evaluate_type(ctx, cc, type_idx, fn_stack, t);
		var fields := fill(-1, array_length);
		for i := 0 to array_length do
			ctx, fields[i] := evaluate_type(ctx, cc, pcode_Array_Create_get_arg(instr, i), fn_stack, t);
		ctx, l := generate_Array_Create(ctx, at, fields, t);
		return ctx, l;
	]
	if opcode = P_Array_String then [
		var blob := pcode_Array_String_get_blob(instr);
		var l : int;
		ctx, l := generate_Array_String(ctx, blob);
		return ctx, l;
	]
	if opcode = P_Array_Unicode then [
		var blob := pcode_Array_Unicode_get_blob(instr);
		var l : int;
		ctx, l := generate_Array_Unicode(ctx, blob);
		return ctx, l;
	]
	if opcode = P_Array_Load then [
		var at ai l : int;
		if is_non_const(ctx, cc, pcode_Array_Load_get_array(instr)) or
		   is_non_const(ctx, cc, pcode_Array_Load_get_index(instr)) then
			goto uses_non_const;
		ctx, at := evaluate_type(ctx, cc, pcode_Array_Load_get_array(instr), fn_stack, t);
		ctx, ai := evaluate_type(ctx, cc, pcode_Array_Load_get_index(instr), fn_stack, t);
		ctx, l := generate_Array_Load(ctx, at, ai, t);
		return ctx, l;
	]
	if opcode = P_Array_Sub then [
		var aa am an l : int;
		if is_non_const(ctx, cc, pcode_Array_Sub_get_array(instr)) or
		   is_non_const(ctx, cc, pcode_Array_Sub_get_start(instr)) or
		   is_non_const(ctx, cc, pcode_Array_Sub_get_end(instr)) then
			goto uses_non_const;
		ctx, aa := evaluate_type(ctx, cc, pcode_Array_Sub_get_array(instr), fn_stack, t);
		ctx, am := evaluate_type(ctx, cc, pcode_Array_Sub_get_start(instr), fn_stack, t);
		ctx, an := evaluate_type(ctx, cc, pcode_Array_Sub_get_end(instr), fn_stack, t);
		ctx, l := generate_Array_Sub(ctx, aa, am, an);
		return ctx, l;
	]
	if opcode = P_Array_Skip then [
		var aa am an l : int;
		if is_non_const(ctx, cc, pcode_Array_Skip_get_array(instr)) or
		   is_non_const(ctx, cc, pcode_Array_Skip_get_start(instr)) then
			goto uses_non_const;
		ctx, aa := evaluate_type(ctx, cc, pcode_Array_Skip_get_array(instr), fn_stack, t);
		ctx, am := evaluate_type(ctx, cc, pcode_Array_Skip_get_start(instr), fn_stack, t);
		ctx, l := generate_Array_Skip(ctx, aa, am);
		return ctx, l;
	]
{
	if opcode = P_Array_Append then [
		abort unimplemented("evaluate_type: P_Array_Append");
	]
}
	if opcode = P_IO then [
		abort compiler_error("Exceptions can't be used as type parameters", t);
	]
	if opcode = P_Copy or opcode = P_Args then [
uses_non_const:
		if cc.root then
			return ctx, typ;
		if is_exception cc.lambda_redirect, exception_class cc.lambda_redirect = ec_sync and exception_type cc.lambda_redirect = error_record_field_not_initialized then
			abort compiler_error("Variable used in type should be const", t);
		if cc.lambda_redirect[typ] >= 0 then
			return ctx, cc.lambda_redirect[typ];
		abort exception_make(int, ec_sync, error_user3, typ, false);
	]
	if opcode = P_ForAll then [
		var l : int;
		ctx, l := alloc_local_variable(ctx, T_Bool, true, false);
		var at : int;
		ctx, at := evaluate_type(ctx, cc, pcode_ForAll_get_type(instr), fn_stack, t);
		var new_fn_stack : compare_fn_stack := compare_fn_stack.[
			cc : cc,
			main_def : pcode_ForAll_get_result(instr),
			dest_def : l,
			dest_types : [ at ],
		];
		fn_stack +<= new_fn_stack;
		var ac : int;
		ctx, ac := evaluate_type(ctx, cc, pcode_ForAll_get_condition(instr), fn_stack, t);
		ctx := set_defined_here(ctx, l);
		ctx := generate_ForAll(ctx, l, at, ac);
		return ctx, l;
	]
	abort internal("evaluate_type: invalid opcode " + ntos(opcode));
]

fn evaluate_type_var(ctx : function_context, cc : compare_context, typ : int, fn_stack : list(compare_fn_stack), t : tokens) : (function_context, int)
[
	var a := ctx.allow_vars;
	ctx.allow_vars := true;
	var l : int;
	ctx, l := evaluate_type(ctx, cc, typ, fn_stack, t);
	ctx.allow_vars := a;
	return ctx, l;
]

fn array_shape(ctx : function_context, cc : compare_context, a : int, t : tokens) : (bool, compare_context, list(int))
[
	var instrm := get_defined_maybe(cc, a);
	if instrm is j then [
		var success, fid, args, ret_idx := decode_call(ctx, cc, a, instrm.j);
		if success, fid.path_index = 0, fid.unit_string = i_encode("system"), not fid.program, fid.function_index = [ predefined_xarray ] then [
			if len(args) <> 2 then
				abort internal("array_shape: array doesn't have two arguments: " + ntos(len(args)));
			var list_cc := args[0].cc;
			var list_idx := args[0].idx;
			var inv : list(compare_argument);
			list_cc, list_idx := get_base_definition(ctx, list_cc, list_idx, false);
			var instrm_list := get_defined_maybe(list_cc, list_idx);
			if instrm_list is j, instrm_list.j.opcode = P_Array_Create then [
				var n_args := pcode_Array_Create_get_length(instrm_list.j);
				var shape := empty(int);
				for i := 0 to n_args do
					shape +<= pcode_Array_Create_get_arg(instrm_list.j, i);
				return true, list_cc, shape;
			] else [
				abort compiler_error("The array doesn't have fixed number of dimensions", t);
			]
		]
	]
	return false, empty_compare_context, empty(int);
]

fn list_type(ctx : function_context, cc : compare_context, a : int, err : bool, t : tokens) : (compare_context, int)
[
	var instrm := get_defined_maybe(cc, a);
	if instrm is j then [
		var success, fid, args, ret_idx := decode_call(ctx, cc, a, instrm.j);
		if success, fid.path_index = 0, fid.unit_string = i_encode("system"), not fid.program, fid.function_index = [ predefined_list ] then [
			if len(args) <> 1 then
				abort internal("list_type: list doesn't have one argument: " + ntos(len(args)));
			return args[0].cc, args[0].idx;
		]
		if success, fid.path_index = 0, fid.unit_string = i_encode("system"), not fid.program, fid.function_index = [ predefined_xarray ] then [
			if len(args) <> 2 then
				abort internal("list_type: array doesn't have two arguments: " + ntos(len(args)));
			return args[1].cc, args[1].idx;
		]
	]
	if err then
		abort compiler_error("List or array type expected", t);
	else
		return empty_compare_context, T_InvalidType;
]

fn evaluate_list_type(ctx : function_context, a : int, t : tokens) : (function_context, int)
[
	var cc, typ := get_deep_type_of_var(ctx, a);
	cc, typ := list_type(ctx, cc, typ, true, t);
	return evaluate_type(ctx, cc, typ, empty(compare_fn_stack), t);
]

fn get_list_id : function_unique_id
[
	return function_unique_id.[
		path_index : 0,
		unit_string : i_encode("system"),
		program : false,
		function_index : [ predefined_list ],
	];
]

fn generate_assumes_or_claims(ctx : function_context, a : int, inv : list(compare_argument), cl : bool, t : tokens) : function_context
[
	var pw := ctx.parsing_where;
	ctx.parsing_where := a;
	for i := 0 to len(inv) do [
		var v : int;
		ctx, v := evaluate_type(ctx, inv[i].cc, inv[i].idx, empty(compare_fn_stack), t);
		if not cl then
			ctx := generate_Assume(ctx, v, false);
		else
			ctx := generate_Claim(ctx, v, false);
	]
	ctx.parsing_where := pw;
	return ctx;
]

fn generate_foreach_assumes_or_claims(ctx : function_context, a : int, inv : list(compare_argument), cl : bool, t : tokens) : function_context
[
	//forall(i : int, i >= 0 and i < len(a) ==> inv1(a[i]) and inv2(a[i]) and inv3(a[i]);
	if not len_greater_than(inv, 0) then
		return ctx;

	var l : int;
	ctx, l := alloc_local_variable(ctx, T_Bool, true, false);

	var li : int;
	ctx, li := alloc_local_variable(ctx, T_Integer, true, false);
	ctx := generate_Load_Local_Type(ctx, l, 0, li);

	var z : int;
	ctx, z := generate_Load_Const(ctx, T_Integer, int_to_blob(0));
	var ge : int;
	ctx, ge := alloc_local_variable(ctx, T_Bool, true, false);
	ctx := generate_BinaryOp(ctx, Bin_GreaterEqual, li, z, ge);

	var len_id := function_unique_id.[
		path_index : 0,
		unit_string : i_encode("system"),
		program : false,
		function_index : [ predefined_len ],
	];
	var len_fd := search_function_from_id(ctx, len_id);
	var list_cc, list_typ := list_type(ctx, new_compare_context(ctx), a, false, t);
	var list_ev : int;
	ctx, list_ev := evaluate_type(ctx, list_cc, list_typ, empty(compare_fn_stack), t);
	var ln : list(int);
	ctx, ln := generate_Call(ctx, Call_Mode_Unspecified, len_fd, [ list_ev, a ], [ 0, 0 ], t);

	var ctx, lt := alloc_local_variable(ctx, T_Bool, true, false);
	ctx := generate_BinaryOp(ctx, Bin_Greater, ln[0], li, lt);

	var l_pre : int;
	ctx, l_pre := alloc_local_variable(ctx, T_Bool, true, false);
	ctx := generate_BinaryOp(ctx, Bin_And, ge, lt, l_pre);

	var ai : int;
	ctx, ai := generate_Array_Load(ctx, a, li, t);

	var invs : int;
	ctx, invs := generate_Load_Const(ctx, T_Bool, int_to_blob(1));
	for i := 0 to len(inv) do [
		var pw := ctx.parsing_where;
		ctx.parsing_where := ai;

		var v : int;
		ctx, v := evaluate_type(ctx, inv[i].cc, inv[i].idx, empty(compare_fn_stack), t);

		ctx.parsing_where := pw;

		var invn : int;
		ctx, invn := alloc_local_variable(ctx, T_Bool, true, false);
		ctx := generate_BinaryOp(ctx, Bin_And, invs, v, invn);
		invs := invn;
	]

	var im : int;
	ctx, im := alloc_local_variable(ctx, T_Bool, true, false);
	ctx := generate_BinaryOp(ctx, Bin_GreaterEqual, invs, l_pre, im);

	ctx := set_defined_here(ctx, l);
	ctx := generate_ForAll(ctx, l, T_Integer, im);

	//eval debug("generating " + select(cl, "assume", "claim"));
	if not cl then
		ctx := generate_Assume(ctx, l, false);
	else
		ctx := generate_Claim(ctx, l, false);

	return ctx;
]
